<?xml version="1.0" encoding="UTF-8"?>

<xs:schema elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="urn:ihe:qrph:sdc:2016" xmlns="urn:ihe:qrph:sdc:2016">


   <xs:include schemaLocation="SDCResources.xsd"/>
   <xs:element name="___ListHelpers___" abstract="true" final="#all" block="#all"/>
   <xs:attribute default="false" name="useDelimiter" type="xs:boolean"/>
   <xs:attribute default=" " name="delimiter">
      <xs:simpleType>
         <xs:restriction base="xs:string">
            <xs:enumeration value="|"/>
            <xs:enumeration value=","/>
            <xs:enumeration value=":"/>
            <xs:enumeration value=";"/>
            <xs:enumeration value="="/>
            <xs:enumeration value="."/>
            <xs:enumeration value="/"/>
            <xs:enumeration value="\"/>
            <xs:enumeration value="^"/>
            <xs:enumeration value="&amp;"/>
            <xs:enumeration value="*"/>
            <xs:enumeration value="~"/>
            <xs:enumeration value="`"/>
            <xs:enumeration value="!"/>
            <xs:enumeration value="%"/>
            <xs:minLength value="0"/>
            <xs:maxLength value="1"/>
            <xs:enumeration value=" "/>
            <xs:whiteSpace value="preserve"/>
         </xs:restriction>
      </xs:simpleType>
   </xs:attribute>
   <xs:element name="___BasicTypes___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="BoolType000" abstract="true">
      <xs:annotation>
         <xs:documentation>List of bool values or references to bool values inside a string list.  Allows constraints on the values in the list. Each value in the list must be validated per the constraints in the list attributes.

Precede named references with "$" to distinguish them from literal strings. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute name="val" type="xs:boolean"/>
            <xs:attributeGroup ref="BoolAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="BoolListType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of Boolean values or references to Boolean values inside a string list.  Allows constraints on the values in the list. Each value in the list must be validated per the constraints in the list attributes.  True is represented as 1, and false is 0.

Precede named references with "$" to distinguish them from literal strings. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attributeGroup ref="ListAttributes"/>
            <xs:attributeGroup ref="BoolAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="NumType" abstract="true">
      <xs:annotation>
         <xs:documentation>Numeric value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute name="val" type="xs:double"/>
            <xs:attributeGroup ref="NumericAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="NumListType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of numeric values or references to numeric values inside a string list.  Allows constraints on the values in the list. Each value in the list must be validated per the constraints in the list attributes.

Precede named references with "$" to distinguish them from literal strings. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attributeGroup ref="ListAttributes"/>
            <xs:attributeGroup ref="NumericAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="IntegerType" abstract="true">
      <xs:annotation>
         <xs:documentation>Numeric value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute name="val" type="xs:long"/>
            <xs:attributeGroup ref="IntegerAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="IntegerListType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of numeric values or references to numeric values inside a string list.  Allows constraints on the values in the list. Each value in the list must be validated per the constraints in the list attributes.

Precede named references with "$" to distinguish them from literal strings. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attributeGroup ref="ListAttributes"/>
            <xs:attributeGroup ref="IntegerAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTimeType" abstract="true">
      <xs:annotation>
         <xs:documentation>DateTime value.

Precede named references with "$" to distinguish them from literal strings. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute name="val" type="xs:string"/>
            <xs:attributeGroup ref="DateTimeAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTimeListType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of dateTime items and or named references to objects that return dateTime values.  Precede named references with "$" to distinguish them from literal strings. Strings that actually start with "$" should be escaped with "\$".</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute ref="dataTypeDateTime"/>
            <xs:attributeGroup ref="ListAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="AnyListType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of typed items and or named references to objects that return typed values.  Precede named references with "$" to distinguish them from literal strings. Strings that actually start with "$" should be escaped with "\$".
</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute ref="dataTypeListAll"/>
            <xs:attribute name="pattern" type="xs:string"/>
            <xs:attributeGroup ref="ListAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="StrType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of string values or references to string values inside a string list.  Allows constraints on the values in the list. Each value in the list must be validated per the constraints in the list attributes.

Precede named references with "$" to distinguish them from literal strings. </xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute name="val" type="xs:string"/>
            <xs:attributeGroup ref="StringAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="StrListType" abstract="true">
      <xs:annotation>
         <xs:documentation>List of typed items and or named references to objects that return typed values.  Precede named references with "$" to distinguish them from literal strings. Strings that actually start with "$" should be escaped with "\$".
</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attributeGroup ref="StringAttributes"/>
            <xs:attribute fixed="string" name="X_dataTypeString"/>
            <xs:attributeGroup ref="ListAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___ReturnTypes___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="ExceptionType">
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute ref="not"/>
            <xs:attribute default="EmptyOrMissing" name="exceptionType">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="Empty"/>
                     <xs:enumeration value="Missing"/>
                     <xs:enumeration value="EmptyOrMissing"/>
                     <xs:enumeration value="NaN"/>
                     <xs:enumeration value="Error"/>
                     <xs:enumeration value="EmptyMissingOrNaN"/>
                     <xs:enumeration value="IncompatibleDataType"/>
                     <xs:enumeration value="Other Exception"/>
                     <xs:enumeration value="ExceedsBounds"/>
                     <xs:enumeration value="Overflow"/>
                     <xs:enumeration value="Underflow"/>
                     <xs:enumeration value="BadPointerToFormItem"/>
                     <xs:enumeration value="ExpectedList"/>
                     <xs:enumeration value="ExpectedAtomicDataType"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="errorMessage" type="xs:string"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnBaseType">
      <xs:annotation>
         <xs:documentation>Base type for all atomic data types</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:choice>
               <xs:element name="Exception" type="ExceptionType" minOccurs="0"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnListBaseType">
      <xs:annotation>
         <xs:documentation>Base type for all list data types</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:choice>
               <xs:element name="Exception" type="ExceptionType" minOccurs="0"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="DataTypes_DEType"/>
               <xs:element name="ReturnList" type="ReturnListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnAtomicOrListType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="DataTypes_DEType"/>
               <xs:element name="ReturnList" type="ReturnListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnAtomicType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="DataTypes_DEType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnListType">
      <xs:complexContent>
         <xs:extension base="ReturnListBaseType">
            <xs:choice>
               <xs:element name="Return" type="AnyListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnStrType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="DataTypeString_StypeEnum"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnStrListType">
      <xs:complexContent>
         <xs:extension base="ReturnListBaseType">
            <xs:choice>
               <xs:element name="Return" type="StrListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnBoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="boolean_DEtype" minOccurs="0"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnBoolListType">
      <xs:complexContent>
         <xs:extension base="ReturnListBaseType">
            <xs:choice>
               <xs:element name="Return" type="BoolListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnNumType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="DataTypesNumeric_DEType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnNumListType">
      <xs:complexContent>
         <xs:extension base="ReturnListBaseType">
            <xs:choice>
               <xs:element name="Return" type="NumListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnIntegerType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="long_DEtype"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnIntegerListType">
      <xs:complexContent>
         <xs:extension base="ReturnListBaseType">
            <xs:choice>
               <xs:element name="Return" type="IntegerListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnDateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnBaseType">
            <xs:choice>
               <xs:element name="Return" type="DataTypes_DEType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="ReturnDateTimeListType">
      <xs:complexContent>
         <xs:extension base="ReturnListBaseType">
            <xs:choice>
               <xs:element name="Return" type="DateTimeListType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___RepeatToListTypes___" abstract="true" final="#all" block="#all">
      <xs:annotation>
         <xs:documentation>ToDo: Need list types for all FuncRef types</xs:documentation>
      </xs:annotation>
   </xs:element>
   <xs:complexType name="Repeats.StrListType">
      <xs:complexContent>
         <xs:extension base="ReturnStrListType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Repeats.BoolListType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolListType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Repeats.NumListType">
      <xs:annotation>
         <xs:documentation>Gather all repeats of a target response and create a list of all the responses</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnNumListType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Repeats.IntegerListType">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerListType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Repeats.DateTimeListType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeListType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___ReferenceTypes___" abstract="true" final="#all" block="#all">
      <xs:annotation>
         <xs:documentation>ToDo: Need list types for all FuncRef types</xs:documentation>
      </xs:annotation>
   </xs:element>
   <xs:complexType name="RefBaseType">
      <xs:annotation>
         <xs:documentation>Reference Type that points to a named object and returns the Return element's value of the object.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ItemNameAttributeType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefType">
      <xs:annotation>
         <xs:documentation>Reference Type that points to a named object and returns the Return element's value of the object.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefBoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefStrType">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefNumType">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefIntegerType000">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefDateTimeType000">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___ReferenceRuleTypes___" abstract="true" final="#all" block="#all">
      <xs:annotation>
         <xs:documentation>ToDo: Need list types for all FuncRef types</xs:documentation>
      </xs:annotation>
   </xs:element>
   <xs:complexType name="RefRuleType">
      <xs:annotation>
         <xs:documentation>Reference Type that points to a named object and returns the Return element's value of the object.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefRuleBoolType000">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:attribute ref="not"/>
            <xs:attribute name="itemName" type="xs:NCName" use="required">
               <xs:annotation>
                  <xs:documentation>The @name attribute of the referenced element.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefRuleStrType000">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefRuleNumType000">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefRuleIntegerType000">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefRuleDateTimeType000">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___ReferenceListTypes___" abstract="true" final="#all" block="#all">
      <xs:annotation>
         <xs:documentation>ToDo: Need list types for all FuncRef types</xs:documentation>
      </xs:annotation>
   </xs:element>
   <xs:complexType name="RefListType">
      <xs:complexContent>
         <xs:extension base="ReturnListType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefStrListType">
      <xs:complexContent>
         <xs:extension base="ReturnStrListType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefNumListType">
      <xs:complexContent>
         <xs:extension base="ReturnNumListType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefIntegerListType">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerListType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefBoolListType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolListType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="RefDateTimeListType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeListType">
            <xs:sequence>
               <xs:element name="Ref" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___InputStrReturnGroupTypes___" abstract="true" final="#all" block="#all"/>
   <xs:complexType abstract="true" name="InputStr_ReturnType000">
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:sequence>
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputStr_ReturnIntegerType">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType">
            <xs:sequence>
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputStr_ReturnBoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="StringPredicate" type="String.Functions.BoolType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputStr_ReturnStrType">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence minOccurs="0">
               <xs:element minOccurs="1" name="InputString" type="Any.Functions.StrType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputStr_ReturnListType">
      <xs:complexContent>
         <xs:extension base="ReturnListType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
            <xs:attribute ref="useDelimiter">
               <xs:annotation>
                  <xs:documentation>If a delimiter is not used, then any white space will delimit the list items.  The default delimiter is a space.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default=" " ref="delimiter"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InputStr_ReturnStrListType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnStrListType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
            <xs:attribute ref="useDelimiter">
               <xs:annotation>
                  <xs:documentation>If a delimiter is not used, then any white space will delimit the list items.  The default delimiter is a space.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default=" " ref="delimiter"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InputStr_ReturnNumListType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnNumListType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
            <xs:attribute ref="useDelimiter">
               <xs:annotation>
                  <xs:documentation>If a delimiter is not used, then any white space will delimit the list items.  The default delimiter is a space.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default=" " ref="delimiter"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InputStr_ReturnIntegerListType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerListType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
            <xs:attribute ref="useDelimiter">
               <xs:annotation>
                  <xs:documentation>If a delimiter is not used, then any white space will delimit the list items.  The default delimiter is a space.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default=" " ref="delimiter"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InputStr_ReturnDateTimeListType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeListType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
            <xs:attribute ref="useDelimiter">
               <xs:annotation>
                  <xs:documentation>If a delimiter is not used, then any white space will delimit the list items.  The default delimiter is a space.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default=" " ref="delimiter"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InputStr_ReturnBoolListType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnBoolListType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputStr" type="String.Functions.StrType"/>
            </xs:sequence>
            <xs:attribute ref="useDelimiter">
               <xs:annotation>
                  <xs:documentation>If a delimiter is not used, then any white space will delimit the list items.  The default delimiter is a space.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default=" " ref="delimiter"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___InputListTypes___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="InputList_ReturnAnyType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:sequence>
               <xs:element minOccurs="1" name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputList_ReturnIntegerType">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType">
            <xs:sequence>
               <xs:element name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputList_ReturnNumType">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:sequence>
               <xs:element name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputList_ReturnStrType111">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence>
               <xs:element name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputList_ReturnBoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType abstract="true" name="InputList_ReturnDateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InputList_ReturnListType" abstract="true">
      <xs:complexContent>
         <xs:extension base="ReturnListType">
            <xs:sequence>
               <xs:element minOccurs="1" name="InputList" type="Any.Functions.ListType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___StringFunctions___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="String.Functions.StrType">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:choice minOccurs="0">
               <xs:element name="LiteralString" type="string_Stype"/>
               <xs:element name="Reference" type="RefStrType"> </xs:element>
               <xs:element name="CustomFunction" type="FuncStrType"/>
               <xs:element name="ListOperationToString111" type="InputList_ReturnStrType111"/>
               <xs:element name="List" type="SetAttrValueType"/>
               <xs:element name="ListIndexToString" type="List.GetItemAtIndex.StrType"/>
               <xs:element name="ListToString" type="List.Convert.StringType"/>
               <xs:element name="StringToLower" type="String.ToLower.StrType"/>
               <xs:element name="StringToUpper" type="String.ToUpper.StrType"/>
               <xs:element name="Trim" type="String.Trim.StrType"/>
               <xs:element name="Substring" type="String.Substring.StrType"/>
               <xs:element name="ReplaceByPattern" type="String.ReplacePattern.StrType"/>
               <xs:element minOccurs="1" name="ReplaceAtIndex" type="String.ReplaceAtIndex.StrType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Substring.StrType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrType">
            <xs:attribute name="length" type="xs:unsignedLong"/>
            <xs:attribute default="0" name="start" type="xs:unsignedLong"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Trim.StrType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrType">
            <xs:attribute default="Trim" name="trimType">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="LTrim"/>
                     <xs:enumeration value="RTrim"/>
                     <xs:enumeration value="Trim"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.ReplacePattern.StrType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrType">
            <xs:attribute name="patternType" type="xs:string" use="required"/>
            <xs:attribute name="replacePattern" type="xs:string" use="required"/>
            <xs:attribute name="index" type="xs:nonNegativeInteger" use="required"/>
            <xs:attribute default="all" name="flags">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="all"/>
                     <xs:enumeration value="first"/>
                     <xs:enumeration value="last"/>
                     <xs:enumeration value="instanceFromStart"/>
                     <xs:enumeration value="instanceFromEnd"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.PatternMatch.ListType000">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnListType">
            <xs:attribute name="patternType" type="xs:string" use="required"/>
            <xs:attribute name="pattern" type="xs:string" use="required"/>
            <xs:attribute name="startItem" type="xs:nonNegativeInteger" use="required"/>
            <xs:attribute name="startMatch" type="xs:nonNegativeInteger" use="required">
               <xs:annotation>
                  <xs:documentation>Start copying to the new list only after the @startMatch (i.e., first, second...) match.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="count" type="xs:nonNegativeInteger" use="required">
               <xs:annotation>
                  <xs:documentation>The max number of items to copy into the new list.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default="all" name="X_flags">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="all"/>
                     <xs:enumeration value="first"/>
                     <xs:enumeration value="last"/>
                     <xs:enumeration value="instanceFromStart"/>
                     <xs:enumeration value="instanceFromEnd"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.ReplaceAtIndex.StrType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrType">
            <xs:attribute name="startIndexInclusive" type="xs:nonNegativeInteger" use="required"/>
            <xs:attribute name="endIndexInclusive" type="xs:nonNegativeInteger" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.ToLower.StrType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.ToUpper.StrType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.IsNull.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.IsEmpty.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.IsNullOrEmpty.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.StartsWith.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType">
            <xs:attribute name="substring" type="xs:string" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.EndsWith.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType">
            <xs:attribute name="substring" type="xs:string" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Like.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType">
            <xs:attribute name="patternType" type="xs:string" use="required"/>
            <xs:attribute name="pattern" type="xs:string" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Compare.IntegerType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnIntegerType">
            <xs:sequence>
               <xs:element name="CompareString" type="String.Functions.StrType"> </xs:element>
            </xs:sequence>
            <xs:attribute default="true" name="ignoreCase" type="xs:boolean"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="StrList.Count.IntegerType">
      <xs:annotation>
         <xs:documentation>Input a list (of type string) and return a count of the items in the list.  If matchPattern is empty, then count all items in the list.  If matchPattern is present, count only the items that match the pattern.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnIntegerType">
            <xs:attribute name="matchPattern" type="xs:string"> </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Contains.IntegerType">
      <xs:annotation>
         <xs:documentation>Return the number of matches to the pattern or substring</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnIntegerType">
            <xs:attribute name="substring" type="xs:string" use="required"/>
            <xs:attribute name="patternType" type="xs:string" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Contains.BoolType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolType">
            <xs:attribute name="substring" type="xs:string" use="required"/>
            <xs:attribute name="patternType" type="xs:string" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Length.IntegerType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnIntegerType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Split.ListType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnListType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Split.StrListType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnStrListType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Split.NumListType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnNumListType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Split.IntegerListType000">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnIntegerListType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Split.DateTimeListType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnDateTimeListType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Split.BoolListType000">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnBoolListType"> </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="StrList.IndexOf.IntegerType">
      <xs:complexContent>
         <xs:extension base="InputStr_ReturnIntegerType">
            <xs:attribute name="matchExpression" type="xs:string"/>
            <xs:attribute name="matchPattern" type="xs:string"/>
            <xs:attribute name="index" type="xs:positiveInteger"/>
            <xs:attribute name="matchType">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="firstMatch"/>
                     <xs:pattern value=""/>
                     <xs:enumeration value="lastMatch"/>
                     <xs:enumeration value="indexMatch"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___ListFunctions___" abstract="true" final="#all" block="#all"> </xs:element>
   <xs:complexType name="List.InsertAtIndex.ListType">
      <xs:complexContent>
         <xs:extension base="InputList_ReturnListType">
            <xs:sequence>
               <xs:element name="X_SourceList" type="Any.Functions.ListType"/>
               <xs:choice/>
               <xs:element minOccurs="1" name="InsertValue" type="DataTypes_SType"/>
               <xs:element name="RefListGroup111"/>
               <xs:element name="RefGroup111"/>
               <xs:element name="RefList111" type="RefListType"/>
               <xs:element name="RefNum111" type="RefNumListType"/>
               <xs:element name="Numerics" type="Any.Functions.NumListOrNumType111"/>
               <xs:element name="Strings">
                  <xs:complexType>
                     <xs:sequence>
                        <xs:element name="StrFunctions" type="Any.Functions.StrType"/>
                        <xs:element name="StrListFunctions">
                           <xs:complexType>
                              <xs:choice>
                                 <xs:element name="StrToStrList" type="InputStr_ReturnStrListType"/>
                                 <xs:element name="RepeatsToStrList" type="Repeats.StrListType"/>
                                 <xs:element name="Str.Split.StrList" type="String.Split.StrListType"/>
                              </xs:choice>
                           </xs:complexType>
                        </xs:element>
                     </xs:sequence>
                  </xs:complexType>
               </xs:element>
               <xs:element name="DateTimes">
                  <xs:complexType>
                     <xs:sequence>
                        <xs:element name="DateTime111" type="Any.Functions.DateTimeType"/>
                        <xs:element name="RepeatsToList" type="Repeats.DateTimeListType"/>
                        <xs:element name="StrSplitToList" type="String.Split.DateTimeListType"/>
                     </xs:sequence>
                  </xs:complexType>
               </xs:element>
               <xs:element name="Bool111" type="Any.Functions.BoolType"/>
               <xs:element name="aaaaa"/>
               <xs:element name="Base64111"/>
            </xs:sequence>
            <xs:attribute name="index" type="xs:positiveInteger" use="required"/>
            <xs:attribute name="insertType" default="insertAtIndex">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="replaceAtIndex"/>
                     <xs:enumeration value="insertAtIndex"/>
                     <xs:enumeration value="insertAfterIndex"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.InsertListAtIndex.ListType"/>
   <xs:complexType name="List.InsertAtomAtIndex.NumListType"/>
   <xs:complexType name="List.InsertAtomAtIndex.StrListType"/>
   <xs:complexType name="List.InsertAtomAtIndex.DateTimeListType"/>
   <xs:complexType name="List.InsertAtomAtIndex.BoolListType"/>
   <xs:complexType name="List.InsertAtomAtIndex.Base64ListType"/>
   <xs:complexType name="List.Filter.ListType000">
      <xs:complexContent>
         <xs:extension base="InputList_ReturnListType">
            <xs:attribute name="patternType" type="xs:string" use="required"/>
            <xs:attribute name="pattern" type="xs:string" default="*">
               <xs:annotation>
                  <xs:documentation>Default is match everything</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="startItem" type="xs:nonNegativeInteger" default="0">
               <xs:annotation>
                  <xs:documentation>Default is 0, meaning, start from the first item in the list</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="startMatch" type="xs:nonNegativeInteger" default="0">
               <xs:annotation>
                  <xs:documentation>Start copying to the new list only after the @startMatch (i.e., first, second...) match.  Default is 0, meaning, start from the first match</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="count" type="xs:nonNegativeInteger" default="0">
               <xs:annotation>
                  <xs:documentation>The max number of items to copy into the new list.  If the value is 0, then count is unlimited.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="startLooking" type="xs:nonNegativeInteger" default="0">
               <xs:annotation>
                  <xs:documentation>Start looking for matches only at the @startLooking item in the list.  Default is 0, meaning, start looking for a match in the first item.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="stopLooking" type="xs:nonNegativeInteger" default="0">
               <xs:annotation>
                  <xs:documentation>Stop looking for matches only after the @stopLooking item in the list match.  Default is 0, meaning, attempt a match to all items</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default="all" name="X_flags">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="all"/>
                     <xs:enumeration value="first"/>
                     <xs:enumeration value="last"/>
                     <xs:enumeration value="instanceFromStart"/>
                     <xs:enumeration value="instanceFromEnd"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.RemoveAtIndex.ListType">
      <xs:annotation>
         <xs:documentation>Remove list items beginning with the index, and continue to remove the number of items specified in @items.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnListType">
            <xs:attribute name="index" type="xs:positiveInteger" default="1"/>
            <xs:attribute name="count" type="xs:positiveInteger" default="1"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.GetItemAtIndex.AnyType000">
      <xs:annotation>
         <xs:documentation>Return the item at a supplied index (zero-based).</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnAnyType">
            <xs:attribute name="index" type="xs:positiveInteger"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.GetItemAtIndex.StrType">
      <xs:annotation>
         <xs:documentation>Return the item at a supplied index (zero-based).</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnStrType111">
            <xs:attribute name="index" type="xs:positiveInteger"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.GetItemAtIndex.NumType000">
      <xs:annotation>
         <xs:documentation>Return the numeric item at a supplied index (zero-based).</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnNumType">
            <xs:attribute name="index" type="xs:positiveInteger"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.GetItemAtIndex.BoolType000">
      <xs:annotation>
         <xs:documentation>Return the item at a supplied index (zero-based).</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnBoolType">
            <xs:attribute name="index" type="xs:positiveInteger"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.GetItemAtIndex.DateTimeType000">
      <xs:annotation>
         <xs:documentation>Return the item at a supplied index (zero-based).</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnDateTimeType">
            <xs:attribute name="index" type="xs:positiveInteger"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType final="" name="List.MonadicFunctions.NumType111">
      <xs:complexContent>
         <xs:extension base="InputList_ReturnNumType">
            <xs:attribute name="function">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="Count"/>
                     <xs:enumeration value="SizeKB"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType final="" name="List.MonadicFunctions.BoolType111">
      <xs:complexContent>
         <xs:extension base="InputList_ReturnBoolType">
            <xs:attribute name="function">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="IsEmpty"/>
                     <xs:enumeration value="IsNotEmpty"/>
                     <xs:enumeration value="IsNumeric"/>
                     <xs:enumeration value="IsString"/>
                     <xs:enumeration value="IsBoolean"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___DateTimeFunctions___" abstract="true" final="#all" block="#all"> </xs:element>
   <xs:complexType name="DateTimeFunctions.AnyType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="X_LiteralDateTime" type="DateTimeType"/>
               <xs:element name="GetListItem.DateTime" type="List.GetItemAtIndex.DateTimeType000"/>
               <xs:element name="NiladicFunctions.DateTime" type="NiladicFunctions.DateTimeType"> </xs:element>
               <xs:element name="DateTime.MonadicFunctions.DateTime" type="DateTime.MonadicFunctions.DateTimeType"> </xs:element>
               <xs:element name="DateTime.MonadicFunctions.Boolean" type="DateTime.MonadicFunctions.BooleanType"> </xs:element>
               <xs:element name="DateTime.DiffFunctions.DateTime" type="DateTime.DiffFunctions.DateTimeType"> </xs:element>
               <xs:element name="DateTime.AddFunctions.DateTime" type="DateTime.AddFunctions.DateTimeType"> </xs:element>
               <xs:element name="DateTime.Format.String" type="DateTime.Format.StringType"> </xs:element>
               <xs:element name="String.Parse.DateTime" type="String.Convert.DateTimeType"> </xs:element>
               <xs:element name="DateTime.Compare.Integer" type="DateTime.Compare.IntegerType111"> </xs:element>
               <xs:element name="DateTimeListFunctions" type="DateTime.AddFunctions.DateTimeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="NiladicFunctions.DateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:attribute name="function" use="required">
               <xs:simpleType>
                  <xs:restriction base="xs:string">

                     <xs:enumeration value="Now"/>
                     <xs:enumeration value="CurrentTime"/>
                     <xs:enumeration value="CurrentDate"/>
                     <xs:enumeration value="CurrentMonthStart"/>
                     <xs:enumeration value="CurrentWeekStart"/>
                     <xs:enumeration value="CurrentWeekStart"/>
                     <xs:enumeration value="CurrentYearStart"/>

                     <xs:enumeration value="Tomorrow"/>
                     <xs:enumeration value="DayAfterTomorrow"/>
                     <xs:enumeration value="NextMon"/>
                     <xs:enumeration value="NextTues"/>
                     <xs:enumeration value="NextWed"/>
                     <xs:enumeration value="NextThurs"/>
                     <xs:enumeration value="NextFri"/>
                     <xs:enumeration value="NextSat"/>
                     <xs:enumeration value="NextSun"/>

                     <xs:enumeration value="NextWeek"/>
                     <xs:enumeration value="NextTwoWeeks"/>
                     <xs:enumeration value="NextThreeWeeks"/>
                     <xs:enumeration value="NextMonth"/>
                     <xs:enumeration value="NextYear"/>

                     <xs:enumeration value="Yesterday"/>

                     <xs:enumeration value="LastMon"/>
                     <xs:enumeration value="LastTues"/>
                     <xs:enumeration value="LastWed"/>
                     <xs:enumeration value="LastThurs"/>
                     <xs:enumeration value="LastFri"/>
                     <xs:enumeration value="LastSat"/>
                     <xs:enumeration value="LastSun"/>

                     <xs:enumeration value="LastWeek"/>
                     <xs:enumeration value="TwoWeeksAgo"/>
                     <xs:enumeration value="ThreeWeeksAgo"/>
                     <xs:enumeration value="LastMonth"/>
                     <xs:enumeration value="LastYear"/>

                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute ref="timeZone"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTime.MonadicFunctions.DateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence minOccurs="0">
               <xs:element name="InputDateTime" type="DateTimeFunctions.AnyType"/>
            </xs:sequence>
            <xs:attribute name="function" use="required">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="DatePart"/>
                     <xs:enumeration value="DayPart"/>
                     <xs:enumeration value="DayOfWeek"/>
                     <xs:enumeration value="DayOfYear"/>
                     <xs:enumeration value="HourPart"/>
                     <xs:enumeration value="MilliSecondPart"/>
                     <xs:enumeration value="MinutePart"/>
                     <xs:enumeration value="MonthPart"/>
                     <xs:enumeration value="SecondPart"/>
                     <xs:enumeration value="TimeOfDayPart"/>
                     <xs:enumeration value="YearPart"/>

                     <xs:enumeration value="NextMon"/>
                     <xs:enumeration value="NextTues"/>
                     <xs:enumeration value="NextWed"/>
                     <xs:enumeration value="NextThurs"/>
                     <xs:enumeration value="NextFri"/>
                     <xs:enumeration value="NextSat"/>
                     <xs:enumeration value="NextSun"/>

                     <xs:enumeration value="PrevMon"/>
                     <xs:enumeration value="PrevTues"/>
                     <xs:enumeration value="PrevWed"/>
                     <xs:enumeration value="PrevThurs"/>
                     <xs:enumeration value="PrevFri"/>
                     <xs:enumeration value="PrevSat"/>
                     <xs:enumeration value="PrevSun"/>

                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute ref="timeZone"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTime.MonadicFunctions.BooleanType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="InputDateTime" type="DateTimeFunctions.AnyType"/>
            </xs:sequence>
            <xs:attribute name="function" use="required">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="IsToday"/>
                     <xs:enumeration value="IsThisMonth"/>
                     <xs:enumeration value="IsThisWeek"/>
                     <xs:enumeration value="IsThisYear"/>
                     <xs:enumeration value="IsDaylightSavingsTime"/>
                     <xs:enumeration value="IsLeapYear"/>
                     <xs:enumeration value="IsPast"/>
                     <xs:enumeration value="IsFuture"/>
                     <xs:enumeration value="IsNull"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTime.DiffFunctions.DateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="DateTimeStart" type="DateTimeFunctions.AnyType"/>
               <xs:element name="DateTimeEnd" type="DateTimeFunctions.AnyType"/>
            </xs:sequence>
            <xs:attribute name="function" use="required">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="DateDiffDay"/>
                     <xs:enumeration value="DateDiffHour"/>
                     <xs:enumeration value="DateDiffMilliSecond"/>
                     <xs:enumeration value="DateDiffMinute"/>
                     <xs:enumeration value="DateDiffMonth"/>
                     <xs:enumeration value="DateDiffSecond"/>
                     <xs:enumeration value="DateDiffTick"/>
                     <xs:enumeration value="DateDiffYear"/>
                     <xs:enumeration value="DateDiffDuration"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute ref="timeZone"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTime.AddFunctions.DateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="addDateTimePart" type="Any.Functions.NumType"/>
               <xs:element name="StartDateTime" type="DateTimeFunctions.AnyType"/>
            </xs:sequence>
            <xs:attribute name="function">
               <xs:simpleType>
                  <xs:restriction base="xs:string">

                     <xs:enumeration value="AddYears"/>
                     <xs:enumeration value="AddMonths"/>
                     <xs:enumeration value="AddWeeks"/>
                     <xs:enumeration value="AddDays"/>

                     <xs:enumeration value="AddHours"/>
                     <xs:enumeration value="AddMinutes"/>
                     <xs:enumeration value="AddSeconds"/>
                     <xs:enumeration value="AddMilliSeconds"/>
                     <xs:enumeration value="AddTicks"/>


                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute default="+" name="operator">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="+"/>
                     <xs:enumeration value="-"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute ref="timeZone"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTime.Format.StringType">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence>
               <xs:element name="InputDateTime" type="DateTimeFunctions.AnyType"/>
            </xs:sequence>
            <xs:attribute name="format" default="General date/time (short time) (g)">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="Short date (d)"/>
                     <xs:enumeration value="Long date (D)"/>
                     <xs:enumeration value="Full date/time (short time) (f)"/>
                     <xs:enumeration value="Full date/time (long time) (F)"/>
                     <xs:enumeration value="General date/time (short time) (g)"/>
                     <xs:enumeration value="General date/time (long time) (G)"/>
                     <xs:enumeration value="Month/day pattern (M, m))"/>
                     <xs:enumeration value="Round-trip date/time (O,o)"/>
                     <xs:enumeration value="RFC1123 (R,r)"/>
                     <xs:enumeration value="Sortable date/time (s)"/>
                     <xs:enumeration value="Short time (t)"/>
                     <xs:enumeration value="Long time (T)"/>
                     <xs:enumeration value="Universal sortable date/time (u)"/>
                     <xs:enumeration value="Universal full date/time (U)"/>
                     <xs:enumeration value="Year month (Y,y)"/>
                     <xs:enumeration value="UsePattern"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute ref="timeZone"/>
            <xs:attribute name="pattern" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Need Regex to constrain pattern
Need Reference to Microsoft pattern language
Consider Javascript reference instead</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="DateTime.Compare.IntegerType111">
      <xs:annotation>
         <xs:documentation>Return 0 if equal, 1 if DT1 is larger, and 2 if DT2 is larger????
Should we instead use comparison operators (GT, LTE, EQ etc)??  This woudl return a Bool.

Or perhaps we need 2 functions, one integer and one Bool?</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType">
            <xs:sequence>
               <xs:element name="InputDateTime1" type="DateTimeFunctions.AnyType"/>
               <xs:element name="InputDateTime2" type="DateTimeFunctions.AnyType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:attribute default="Local" name="timeZone">
      <xs:simpleType>
         <xs:restriction base="xs:string">
            <xs:enumeration value="Local"/>
            <xs:enumeration value="UTC"/>
            <xs:enumeration value="LocalMinus1"/>
            <xs:enumeration value="LocalMinus2"/>
            <xs:enumeration value="LocalMinus3"/>
            <xs:enumeration value="LocalPlus1"/>
            <xs:enumeration value="LocalPlus2"/>
            <xs:enumeration value="LocalPlus3"/>
            <xs:enumeration value="Other"/>
         </xs:restriction>
      </xs:simpleType>
   </xs:attribute>
   <xs:element name="___NumericFunctions___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="Num.Function.BoolType111">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType"/>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Integer.Function.Integer111">
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType"/>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Num.Trig.NumType111">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:sequence>
               <xs:element name="ConvertAngle">
                  <xs:complexType>
                     <xs:attribute name="function">
                        <xs:simpleType>
                           <xs:restriction base="xs:string">
                              <xs:enumeration value="DegreesToRadians"/>
                              <xs:enumeration value="RadiansToDegrees"/>
                              <xs:enumeration value=""/>
                           </xs:restriction>
                        </xs:simpleType>
                     </xs:attribute>
                  </xs:complexType>
               </xs:element>
               <xs:element name="TrigRadians">
                  <xs:complexType>
                     <xs:choice maxOccurs="2" minOccurs="2">
                        <xs:element name="AngleRadRef111" type="ParameterValueType"/>
                        <xs:element name="AngleRadValue111" type="ParameterValueType"/>
                     </xs:choice>
                     <xs:attribute name="function">
                        <xs:simpleType>
                           <xs:restriction base="xs:string">
                              <xs:enumeration value="sin"/>
                              <xs:enumeration value="cos"/>
                              <xs:enumeration value="tan"/>
                              <xs:enumeration value="asin"/>
                              <xs:enumeration value="acos"/>
                              <xs:enumeration value="atan"/>
                              <xs:enumeration value="atan2"/>
                              <xs:enumeration value="sinh"/>
                              <xs:enumeration value="cosh"/>
                              <xs:enumeration value="tanh"/>
                              <xs:enumeration value="asinh"/>
                              <xs:enumeration value="acosh"/>
                              <xs:enumeration value="atanh"/>
                           </xs:restriction>
                        </xs:simpleType>
                     </xs:attribute>
                  </xs:complexType>
               </xs:element>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ListAggregate.NumType">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:choice maxOccurs="unbounded">
               <xs:element maxOccurs="unbounded" name="NumValue" type="NumType"/>
               <xs:element name="NumListLiteral" type="NumListType" maxOccurs="unbounded"> </xs:element>
               <xs:element maxOccurs="unbounded" name="FuncNum" type="FuncNumType"/>
               <xs:element name="RefNum" type="RefNumType" maxOccurs="unbounded"/>
               <xs:element name="Functions" type="Any.Functions.NumType" maxOccurs="unbounded"/>
               <xs:element name="NumericConstant" type="NumericConstantsType111" maxOccurs="unbounded"/>
               <xs:element name="NumericFunction" type="Num.NumFunction.NumType" maxOccurs="unbounded"/>
               <xs:element maxOccurs="unbounded" name="NumberFromSet" type="SetFunction.NumListType"/>
               <xs:element maxOccurs="unbounded" name="NumericAttributeValue" type="GetAttrValueType"/>
               <xs:element name="IntegerFunction111" type="Integer.Function.Integer111" maxOccurs="unbounded"/>
               <xs:element maxOccurs="unbounded" name="ScriptNum" type="ScriptCode.NumType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element maxOccurs="unbounded" name="ScriptAny" type="ScriptCode.AnyType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element maxOccurs="unbounded" name="Group" type="ListAggregate.NumType"/>
            </xs:choice>
            <xs:attribute ref="op"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Num.NumFunction.NumType">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:choice>
               <xs:element name="Number" type="DataTypesNumeric_DEType"> </xs:element>
               <xs:element name="ListMath" type="ListAggregate.NumType"/>
               <xs:element name="NumberReference" type="RefNumType"/>
               <xs:element name="ListAggregateNumber" type="ListAggregate.NumType"/>
               <xs:element name="Group" type="Num.NumFunction.NumType"/>
            </xs:choice>
            <xs:attribute name="opMathList">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="RoundMidUp"/>
                     <xs:enumeration value="RoundMidDown"/>
                     <xs:enumeration value="RoundToEven"/>
                     <xs:enumeration value="RoundToOdd"/>
                     <xs:enumeration value="Ceiling"/>
                     <xs:enumeration value="Floor"/>
                     <xs:enumeration value="Inverse"/>
                     <xs:enumeration value="Square"/>
                     <xs:enumeration value="Sqrt"/>
                     <xs:enumeration value="RootX"/>
                     <xs:enumeration value="Abs"/>
                     <xs:enumeration value="Neg">
                        <xs:annotation>
                           <xs:documentation>negate, i.e., multiply by -1</xs:documentation>
                        </xs:annotation>
                     </xs:enumeration>
                     <xs:enumeration value="Power"/>
                     <xs:enumeration value="Exp"/>
                     <xs:enumeration value="Ln"/>
                     <xs:enumeration value="Log2"/>
                     <xs:enumeration value="Log10"/>
                     <xs:enumeration value="LogX"/>
                     <xs:enumeration value="ReturnIfNull">
                        <xs:annotation>
                           <xs:documentation>The value to return if the input value is null.</xs:documentation>
                        </xs:annotation>
                     </xs:enumeration>
                     <xs:enumeration value="IntPart"/>
                     <xs:enumeration value="DecPart"/>
                     <xs:enumeration value="Mod"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="param" type="xs:double"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="SetFunction.NumListType">
      <xs:annotation>
         <xs:documentation>Set functions that work on lists and retun lists.  Examples are union, intersection, etc.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnNumListType">
            <xs:choice maxOccurs="unbounded" minOccurs="0">
               <xs:annotation>
                  <xs:documentation>Run a set function (e.g., union) over numeric types.  The numeric types can derive from any combination of numeric lists and single numeric values/references.</xs:documentation>
               </xs:annotation>
               <xs:element name="NumListLiteral" type="NumListType"> </xs:element>
               <xs:element name="NumListRef" type="RefNumListType"/>
               <xs:element name="NumFunctions" type="Any.Functions.NumType"/>
               <xs:element name="NumListFromRepeat" type="Repeats.NumListType"/>
               <xs:element name="IntListFromRepeat" type="Repeats.IntegerListType"/>
               <xs:element name="Group" type="SetFunction.NumListType"/>
               <xs:element name="StringToNumList" type="String.Split.NumListType"/>
            </xs:choice>
            <xs:attribute name="opListNumeric" default="union">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="union"/>
                     <xs:enumeration value="intersection"/>
                     <xs:enumeration value="difference">
                        <xs:annotation>
                           <xs:documentation>The difference is the first list minus the second list (or group).  All other lists (or groups) are ignored.</xs:documentation>
                        </xs:annotation>
                     </xs:enumeration>
                     <xs:enumeration value="symmetricDifference">
                        <xs:annotation>
                           <xs:documentation>The union of the first list (or group) and the second list (or group), minus the intersection of the 2 lists.  All other lists are ignored.  In other words, this function returns the list itmes that are not in common between the lists.</xs:documentation>
                        </xs:annotation>
                     </xs:enumeration>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___Parameters___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="ParameterItemType111">
      <xs:annotation>
         <xs:documentation>Parameters are named, uniquely identifiable, instances of form properties (e.g., @selected).  They are fed into expressions, which are then used as part of a rule within the form.  Parameters can also be fed into URI expressions used inside a Lookup Endpoint, i.e., URIs that call web services to supply list items (e.g., a list of SNOMED-coded items) to a question.

Parameters using this construct are derived from other locations in the XML instance document, including user-entered Response values.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:attribute ref="dataTypeListAll"/>
            <xs:attribute name="paramName" type="xs:NCName">
               <xs:annotation>
                  <xs:documentation>A locally useful name that describes the parameter</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceItemName" type="xs:NCName" use="required">
               <xs:annotation>
                  <xs:documentation>The @name of an item in the current form that holds the @itemAttribute value that will become the parameter value.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute default="val" name="SourceItemAttribute" type="xs:NCName">
               <xs:annotation>
                  <xs:documentation>The name of any XML attribute on a named element.  The property value is the parameter's value.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ParameterValueType">
      <xs:annotation>
         <xs:documentation>This type describes strongly-typed parameters used in functions and web services.  Values are hard-coded as constants in the XML instance document.  They are not user-entered values.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="DataTypes_SType">
            <xs:attribute name="paramName" type="xs:NCName" use="required"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ParamNumType000">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:group ref="ParameterGroup" maxOccurs="1" minOccurs="1"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="CustomStrListFunction000" type="FuncType" final="">
      <xs:annotation>
         <xs:documentation>ToDo:  Need new types: FuncRef_ReturnStrListType, FuncRef_ReturnListType, FuncRef_ReturnNumListType, BoolList, DateTime, CustomClass? etc...</xs:documentation>
      </xs:annotation>
   </xs:element>
   <xs:complexType name="FuncType">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncBoolType">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a Boolean value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:group ref="FunctionGroup"/>
            <xs:attribute ref="not"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncStrType">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a string value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncNumType">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a numeric value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncDateTimeType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a DateTime value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncIntegerType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a numeric value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnIntegerType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncListType00000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a string list value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnListType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncStrListType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a string list value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnStrListType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncNumListType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a numeric list value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnNumListType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncIntegerListType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a numeric list value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnIntegerListType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncDateTimeListType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a numeric list value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeListType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="FuncBoolListType000">
      <xs:annotation>
         <xs:documentation>Function or web service that returns a numeric list value.  Contains an optional location to store the value.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnBoolListType">
            <xs:group ref="FunctionGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:group name="FunctionGroup">
      <xs:sequence>
         <xs:annotation>
            <xs:documentation/>
         </xs:annotation>
         <xs:element name="Function" type="anyURI_Stype">
            <xs:annotation>
               <xs:documentation>Name of the function or URI of the web service. The Function may use the parameter list and transmit the item name, property and value for each parameter. 

The function must understand the parameters and return an appropriate response of the correct data type.  Guidelines for URI construction syntax will be defined external to this Schema, and may be use-case and implementation-specific.</xs:documentation>
            </xs:annotation>
         </xs:element>
         <xs:element minOccurs="0" name="Security" type="RichTextType">
            <xs:annotation>
               <xs:documentation>Information about securly accessing the web service.  More detailed service patterns may be required.</xs:documentation>
            </xs:annotation>
         </xs:element>
         <xs:group maxOccurs="unbounded" minOccurs="0" ref="ParameterGroup"/>
      </xs:sequence>
   </xs:group>
   <xs:group name="ParameterGroup">
      <xs:choice>
         <xs:annotation>
            <xs:documentation>Ordered list of parameters</xs:documentation>
         </xs:annotation>
         <xs:element name="ParameterRef" type="ParameterItemType111">
            <xs:annotation>
               <xs:documentation>Parameters are named FormDesign items which have property values that need to be supplied to a scripted function or a web service URI.</xs:documentation>
            </xs:annotation>
         </xs:element>
         <xs:element name="ParameterValue" type="ParameterValueType"/>
      </xs:choice>
   </xs:group>
   <xs:attribute name="op">
      <xs:simpleType>
         <xs:restriction base="xs:string">
            <xs:enumeration value="+"/>
            <xs:enumeration value="-"/>
            <xs:enumeration value="*"/>
            <xs:enumeration value="/"/>
            <xs:enumeration value="min"/>
            <xs:enumeration value="max"/>
            <xs:enumeration value="mean"/>
            <xs:enumeration value="median"/>
            <xs:enumeration value="mode"/>
            <xs:enumeration value="stdDev"/>
            <xs:enumeration value="pStdDev"/>
            <xs:enumeration value="count"/>
            <xs:enumeration value="first"/>
            <xs:enumeration value="last"/>
            <xs:enumeration value="midLow"/>
            <xs:enumeration value="midHigh"/>
            <xs:enumeration value="var"/>
            <xs:enumeration value="pVar"/>
         </xs:restriction>
      </xs:simpleType>
   </xs:attribute>
   <xs:element name="___ConversionFunctions___" abstract="true" final="#all">
      <xs:complexType>
         <xs:sequence>
            <xs:element ref="___DateTimeFunctions___"/>
         </xs:sequence>
      </xs:complexType>
   </xs:element>
   <xs:complexType name="Any.Convert.StrType">
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:choice>
               <xs:element name="Input" type="Any.Functions.AnyType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Convert.NumType">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:choice>
               <xs:element name="Input" type="Any.Functions.AnyType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Convert.BoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:choice>
               <xs:element name="Input" type="Any.Functions.AnyType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Convert.DateTimeType">
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence>
               <xs:element name="Input" type="string_DEtype"/>
            </xs:sequence>
            <xs:attribute ref="timeZone"/>
            <xs:attribute name="culture" type="xs:string"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.Convert.ListType">
      <xs:complexContent>
         <xs:extension base="InputList_ReturnListType">
            <xs:attribute default="Truncate" name="truncation">
               <xs:annotation>
                  <xs:documentation>For conversion that result in "shortened" objects (e.g., decimal to integer), this attribute controls how the truncation takes place.  For conversions that would result in fundamental data changes (e.g., long to integer) an exception should be thrown.  However, some types of changes may be acceptable (e.g., DateTime to Time, Decimal to Long).</xs:documentation>
               </xs:annotation>
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="Truncate"/>
                     <xs:enumeration value="Ceiling"/>
                     <xs:enumeration value="Floor"/>
                     <xs:enumeration value="RoundMidUp"/>
                     <xs:enumeration value="RoundMidDown"/>
                     <xs:enumeration value="RoundToEven"/>
                     <xs:enumeration value="RoundToOdd"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="List.Convert.StringType">
      <xs:complexContent>
         <xs:extension base="InputList_ReturnStrType111"/>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ConversionFunctions" abstract="true" block="#all" final="#all">
      <xs:sequence>
         <xs:element name="ToString" type="Any.Convert.StrType"/>
         <xs:element name="ToNum" type="Any.Convert.NumType"/>
         <xs:element name="ToDateTime" type="String.Convert.DateTimeType"/>
         <xs:element name="ToBool" type="Any.Convert.BoolType"/>
         <xs:element name="ListToList" type="List.Convert.ListType"/>
         <xs:element name="ListToString" type="List.Convert.StringType"/>
      </xs:sequence>
   </xs:complexType>
   <xs:element name="___FunctionGroupers___" abstract="true" final="#all" block="#all">
      <xs:complexType>
         <xs:sequence>
            <xs:element ref="___DateTimeFunctions___"/>
         </xs:sequence>
      </xs:complexType>
   </xs:element>
   <xs:group name="ListFunctionsGroup">
      <xs:choice>
         <xs:annotation>
            <xs:documentation>Lists</xs:documentation>
         </xs:annotation>
         <xs:element name="ListLiteral" type="AnyListType"> </xs:element>
         <xs:element name="TypedList" type="ReturnListType"/>
         <xs:element name="LiteralStringList" type="ReturnStrListType"/>
         <xs:element name="FuncList" type="FuncListType00000"/>
         <xs:element name="FuncBoolList" type="FuncBoolListType000"/>
         <xs:element name="FuncDateTimeList" type="FuncDateTimeListType000"/>
         <xs:element name="FuncIntList" type="FuncIntegerListType000"/>
         <xs:element name="FuncNumList" type="FuncNumListType000"/>
         <xs:element name="FuncStrList" type="FuncStrListType000"/>
         <xs:element name="RefList" type="RefListType"/>
         <xs:element name="RefNumList" type="RefNumListType"/>
         <xs:element name="RefIntegerList" type="RefIntegerListType"/>
         <xs:element name="RefStrList" type="RefStrListType"/>
         <xs:element name="RefBoolList" type="RefBoolListType"/>
         <xs:element name="RefDateTimeList" type="RefDateTimeListType"/>
         <xs:element name="ConvertStrToBoolList" type="InputStr_ReturnBoolListType"/>
         <xs:element name="ConvertStrToDateTimeList" type="InputStr_ReturnDateTimeListType"/>
         <xs:element name="ConvertStrToIntegerList" type="InputStr_ReturnIntegerListType"/>
         <xs:element name="ConvertStrToNumList" type="InputStr_ReturnNumListType"/>
         <xs:element name="ConvertStrToStrList" type="InputStr_ReturnStrListType"/>
         <xs:element name="ConvertStrToAnyList" type="InputStr_ReturnListType"/>
         <xs:element name="ConvertAnyList111" type="List.Convert.ListType"/>
         <xs:element name="StringSplitToAnyList" type="String.Split.ListType"/>
         <xs:element name="StringSplitToNumList" type="String.Split.NumListType"/>
         <xs:element name="StringSplitToStrList" type="String.Split.StrListType"/>
         <xs:element name="StringToDateTimeList" type="String.Split.DateTimeListType"/>
         <xs:element name="DateTimeList" type="DateTimeListType"/>
         <xs:element name="BoolList" type="BoolListType"/>
         <xs:element name="InsertAtListIndex" type="List.InsertAtIndex.ListType"/>
         <xs:element name="RemoveAtListIndex" type="List.RemoveAtIndex.ListType"/>
         <xs:element name="ListMatchToList000" type="List.Filter.ListType000"/>
         <xs:element name="ListSetFunctions111" type="Any.ListSetFunctions.ListType111"/>
         <xs:element name="NumListSetFunctions" type="SetFunction.NumListType"/>
         <xs:element name="RepeatBoolList" type="Repeats.BoolListType"/>
         <xs:element name="RepeatDateTimeList" type="Repeats.DateTimeListType"/>
         <xs:element name="RepeatIntegerList" type="Repeats.IntegerListType"/>
         <xs:element name="RepeatNumList" type="Repeats.NumListType"/>
         <xs:element name="RepeatStringList" type="Repeats.StrListType"/>
         <xs:element name="SelectionsToList111">
            <xs:annotation>
               <xs:documentation>Gather all selected items into a list of ListItem names</xs:documentation>
            </xs:annotation>
         </xs:element>
         <xs:element name="UnSelectionsToList111">
            <xs:annotation>
               <xs:documentation>Gather all un-selected items into a list of ListItem names</xs:documentation>
            </xs:annotation>
         </xs:element>
      </xs:choice>
   </xs:group>
   <xs:group name="BoolFunctionsGroup">
      <xs:sequence>
         <xs:element maxOccurs="unbounded" name="Between" type="BetweenType"/>
         <xs:element maxOccurs="unbounded" name="InList" type="InListType"/>
         <xs:element maxOccurs="unbounded" name="Compare" type="CompareType"/>
         <xs:element maxOccurs="unbounded" name="FuncBool" type="FuncBoolType">
            <xs:annotation>
               <xs:documentation/>
            </xs:annotation>
         </xs:element>
         <xs:element maxOccurs="unbounded" name="GetListItem.Bool" type="List.GetItemAtIndex.BoolType000"/>
         <xs:element name="Script" type="ScriptCode.BoolType" maxOccurs="unbounded"/>
         <xs:element name="NumFunction111" type="Num.Function.BoolType111"/>
         <xs:element maxOccurs="unbounded" name="StringPredicateFunction" type="String.Functions.BoolType"/>
         <xs:element maxOccurs="unbounded" name="ListFunction111" type="List.MonadicFunctions.BoolType111"/>
         <xs:element maxOccurs="unbounded" name="ConvertToBool" type="Any.Convert.BoolType"/>
      </xs:sequence>
   </xs:group>
   <xs:complexType name="Any.Functions.AnyType" abstract="true">
      <xs:annotation>
         <xs:documentation>A block of scripting or programming code, provide either directly (ScriptCode), via WebService, or via a Reference to a named Expression elsewhere in the active template.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnAtomicOrListType">
            <xs:choice minOccurs="0">
               <xs:element name="GetResponse" type="RefType"> </xs:element>
               <xs:element name="GetAttributeValue" type="GetAttrValueType">
                  <xs:annotation>
                     <xs:documentation>Identifies, by reference, a named expression at another location in the SDCFormDesign template, using the @name attribute.</xs:documentation>
                  </xs:annotation>
               </xs:element>
               <xs:element name="Func" type="FuncType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element maxOccurs="unbounded" name="Script" type="ScriptCode.AnyType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="ConversionFunctions" type="ConversionFunctions"/>
               <xs:element name="ConvertToNum" type="Any.Convert.NumType"/>
               <xs:element name="BoolFunctions" type="Any.Functions.BoolType"/>
               <xs:element name="NumFunctions" type="Any.Functions.NumListOrNumType111"/>
               <xs:element name="DateTimeFunctions" type="DateTimeFunctions.AnyType"/>
               <xs:element name="StringPredicates" type="String.Functions.BoolType"/>
               <xs:element name="StringFunctions" type="Any.Functions.StrType"/>
               <xs:element name="ListFunctions" type="Any.Functions.ListType"/>
               <xs:element name="GetListItemAt" type="List.GetItemAtIndex.AnyType000"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.AtomicType" abstract="true">
      <xs:annotation>
         <xs:documentation>A block of scripting or programming code, provide either directly (ScriptCode), via WebService, or via a Reference to a named Expression elsewhere in the active template.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnAtomicType">
            <xs:choice minOccurs="0">
               <xs:element name="GetResponse" type="RefType"> </xs:element>
               <xs:element name="GetAttrValue" type="GetAttrValueType">
                  <xs:annotation>
                     <xs:documentation>Identifies, by reference, a named expression at another location in the SDCFormDesign template, using the @name attribute.</xs:documentation>
                  </xs:annotation>
               </xs:element>
               <xs:element name="Func" type="FuncType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element maxOccurs="unbounded" name="Script" type="ScriptCode.AnyType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="ConversionFunctions" type="ConversionFunctions"/>
               <xs:element name="BoolFunctions" type="Any.Functions.BoolType"/>
               <xs:element name="NumFunctions" type="Any.Functions.NumType"/>
               <xs:element name="DateTimeFunctions" type="DateTimeFunctions.AnyType"/>
               <xs:element name="StringPredicates" type="String.Functions.BoolType"/>
               <xs:element name="StringFunctions" type="Any.Functions.StrType"/>
               <xs:element ref="___StrToNumOrNumList"/>
               <xs:element name="GetListItemAt" type="List.GetItemAtIndex.AnyType000"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___StrToNumOrNumList"/>
   <xs:complexType name="List.Aggregate.StrType">
      <xs:annotation>
         <xs:documentation>Input a list (of type string) and return a single list member, or a single value derived by computing a function over the list.  The returned value need is of type string  even if the returned value is an numeric (e.g., count).

The delimiter attributes determine whether a delimiter should be used to separate items in the aggregated list.  If u@seDelimiter is "true", then the delimiter may be selected from the @delimiter list.  The default delimiter is a single space.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="InputList_ReturnStrType111">
            <xs:sequence>
               <xs:element maxOccurs="unbounded" name="List" type="Any.Functions.ListType"/>
            </xs:sequence>
            <xs:attribute name="opStringList">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="concat"/>
                     <xs:enumeration value="min"/>
                     <xs:enumeration value="max"/>
                     <xs:enumeration value="mode"/>
                     <xs:enumeration value="first"/>
                     <xs:enumeration value="last"/>
                     <xs:enumeration value="midLow"/>
                     <xs:enumeration value="midHigh"/>
                     <xs:enumeration value="upper"/>
                     <xs:enumeration value="lower"/>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.StrType">
      <xs:annotation>
         <xs:documentation>A block of scripting or programming code, provide either directly (ScriptCode), via WebService, or via a Reference to a named Expression elsewhere in the active template.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:choice minOccurs="0">
               <xs:element name="GetResponse" type="RefStrType"> </xs:element>
               <xs:element name="GetAttrValue" type="GetStrAttrValueType">
                  <xs:annotation>
                     <xs:documentation>Identifies, by reference, a named expression at another location in the SDCFormDesign template, using the @name attribute.</xs:documentation>
                  </xs:annotation>
               </xs:element>
               <xs:element name="FuncStr" type="FuncStrType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="ConvertToString" type="Any.Convert.StrType"/>
               <xs:element name="FormatDateTime" type="DateTime.Format.StringType"/>
               <xs:element maxOccurs="unbounded" name="Script" type="ScriptCode.StrType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="StringFunction" type="String.Functions.StrType"/>
               <xs:element name="ListToString" type="List.Convert.StringType"/>
               <xs:element name="ListAggregateToString" type="List.Aggregate.StrType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.DateTimeType">
      <xs:annotation>
         <xs:documentation>A block of scripting or programming code, provide either directly (ScriptCode), via WebService, or via a Reference to a named Expression elsewhere in the active template.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:choice minOccurs="0">
               <xs:element name="ConvertToDateTime" type="String.Convert.DateTimeType"/>
               <xs:element name="DateTimeFunction" type="FuncDateTimeType000"/>
               <xs:element name="GetListItem.DateTime" type="List.GetItemAtIndex.DateTimeType000"/>
               <xs:element name="AddFunctions" type="DateTime.AddFunctions.DateTimeType"/>
               <xs:element name="DiffFunctions" type="DateTime.DiffFunctions.DateTimeType"/>
               <xs:element name="MonadicFunctions" type="DateTime.MonadicFunctions.DateTimeType"/>
               <xs:element name="NiladicFunctions" type="NiladicFunctions.DateTimeType"/>
               <xs:element maxOccurs="unbounded" name="Script" type="ScriptCode.DateTimeType"/>
               <xs:element name="StrToDateTime" type="String.Convert.DateTimeType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.NumType">
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:choice minOccurs="0">
               <xs:element name="Constant" type="NumericConstantsType111"/>
               <xs:element name="Ref" type="RefNumType"/>
               <xs:element name="GetAttrValue" type="GetNumAttrValueType">
                  <xs:annotation>
                     <xs:documentation>Identifies, by reference, a named expression at another location in the SDCFormDesign template, using the @name attribute.</xs:documentation>
                  </xs:annotation>
               </xs:element>
               <xs:element ref="___StrToNumOrNumList"/>
               <xs:element name="MathFunction" type="Num.NumFunction.NumType"/>
               <xs:element name="FuncNum" type="FuncNumType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="FuncInt" type="FuncIntegerType000">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="GetListItem.Num" type="List.GetItemAtIndex.NumType000"/>
               <xs:element name="ConvertToNum" type="Any.Convert.NumType"/>
               <xs:element name="IntegerFunction111" type="Integer.Function.Integer111"/>
               <xs:element maxOccurs="unbounded" name="Script" type="ScriptCode.NumType">
                  <xs:annotation>
                     <xs:documentation/>
                  </xs:annotation>
               </xs:element>
               <xs:element name="ListMath" type="ListAggregate.NumType"/>
               <xs:element name="Trig111" type="Num.Trig.NumType111"/>
               <xs:element name="DateTimeComparison" type="DateTime.Compare.IntegerType111">
                  <xs:annotation>
                     <xs:documentation>Return 0 if equal, 1 if DT1 GT DT2, and 2if DT1 LT DT2</xs:documentation>
                  </xs:annotation>
               </xs:element>
               <xs:element name="Group" type="Any.Functions.NumType"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.NumListOrNumType111">
      <xs:annotation>
         <xs:documentation>A block of scripting or programming code, provide either directly (ScriptCode), via WebService, or via a Reference to a named Expression elsewhere in the active template.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="Any.Functions.NumType">
            <xs:choice minOccurs="0">
               <xs:element name="SetFunctions.ReturnNumList" type="SetFunction.NumListType"/>
               <xs:element name="FuncNumList" type="FuncNumListType000"/>
            </xs:choice>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="String.Functions.BoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:choice maxOccurs="unbounded">
               <xs:element maxOccurs="unbounded" name="StartsWith" type="String.StartsWith.BoolType"/>
               <xs:element maxOccurs="unbounded" name="EndsWith" type="String.EndsWith.BoolType"/>
               <xs:element maxOccurs="unbounded" name="Contains" type="String.Contains.BoolType"/>
               <xs:element maxOccurs="unbounded" name="Like" type="String.Like.BoolType"/>
               <xs:element maxOccurs="unbounded" name="IsEmpty" type="String.IsEmpty.BoolType"/>
               <xs:element maxOccurs="unbounded" name="IsNull" type="String.IsNull.BoolType"/>
               <xs:element maxOccurs="unbounded" name="IsNullOrEmpty" type="String.IsNullOrEmpty.BoolType"/>
               <xs:element maxOccurs="unbounded" name="StringPredicate" type="String.Functions.BoolType"/>
               <xs:element name="FunctionBool" type="FuncBoolType" maxOccurs="unbounded"/>
            </xs:choice>
            <xs:attributeGroup ref="BoolAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.BoolType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:group maxOccurs="unbounded" ref="BoolFunctionsGroup"/>
            <xs:attributeGroup ref="BoolAttributes"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.Functions.ListType">
      <xs:complexContent>
         <xs:extension base="ReturnListType">
            <xs:group ref="ListFunctionsGroup"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="Any.ListSetFunctions.ListType111">
      <xs:annotation>
         <xs:documentation>Set functions that work on lists and retun lists.  Examples are union, intersection, etc.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnListType">
            <xs:choice maxOccurs="unbounded" minOccurs="2">
               <xs:element name="X_ListLiteral" type="AnyListType"> </xs:element>
               <xs:element name="X_ListReference" type="RefListType"> </xs:element>
               <xs:element name="X_SetGroup" type="SetFunction.NumListType"/>
               <xs:element name="X_StringToList" type="String.Split.ListType"/>
               <xs:element form="qualified" name="StrLiteral" type="string_DEtype"/>
               <xs:element name="RefStr" type="RefStrType"> </xs:element>
               <xs:element name="AnyFunction" type="Any.Functions.AnyType"/>
               <xs:element name="ListFunctions" type="Any.Functions.ListType"> </xs:element>
               <xs:element name="NumericFunctions" type="Any.Functions.NumListOrNumType111"/>
               <xs:element name="DateTimeFunctions" type="DateTimeFunctions.AnyType"/>
               <xs:element name="BooleanFunctions" type="Any.Functions.BoolType"/>
               <xs:element name="ListToNum" type="ListAggregate.NumType"/>
               <xs:element name="ListToStr" type="List.Convert.StringType"/>
               <xs:element name="IndexedListItemToStr" type="List.GetItemAtIndex.StrType"/>
               <xs:element name="ListToIndex" type="StrList.IndexOf.IntegerType"/>
               <xs:element name="Group" type="Any.ListSetFunctions.ListType111"/>
            </xs:choice>
            <xs:attribute name="opListSet">
               <xs:simpleType>
                  <xs:restriction base="xs:string">
                     <xs:enumeration value="union"/>
                     <xs:enumeration value="intersection"/>
                     <xs:enumeration value="difference">
                        <xs:annotation>
                           <xs:documentation>The difference is the first list minus the second list (or group).  All other lists (or groups) are ignored.</xs:documentation>
                        </xs:annotation>
                     </xs:enumeration>
                     <xs:enumeration value="symmetricDifference">
                        <xs:annotation>
                           <xs:documentation>The union of the first list (or group) and the second list (or group), minus the intersection of the 2 lists.  All other lists are ignored.  In other words, this function returns the list itmes that are not in common between the lists.</xs:documentation>
                        </xs:annotation>
                     </xs:enumeration>
                  </xs:restriction>
               </xs:simpleType>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___ScriptCode___" abstract="true" final="#all" block="#all">
      <xs:complexType>
         <xs:sequence>
            <xs:element ref="___DateTimeFunctions___"/>
         </xs:sequence>
      </xs:complexType>
   </xs:element>
   <xs:complexType name="ScriptCode.AnyType">
      <xs:annotation>
         <xs:documentation>Programming code or pseudocode that describes a calculation.  THe code returns a value of the data type required by the parent Response field.  To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent.  It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs.  The @ type attribute may be used to distinguish between them.  An Extension may be used instead of or along with an Expression and Parameters list.  Expressions may populate Responses that are set to @readOnly = "true" to ensure that all responses are calculated and not latered by the user.  Alternatively, the user may change a value created by (or instead of) the Expression.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:sequence minOccurs="0">
               <xs:element maxOccurs="unbounded" minOccurs="0" name="Parameter" type="ParameterItemType111">
                  <xs:annotation>
                     <xs:documentation>Parameters are named FormDesign items which have property values that need to be supplied to a scripted function or a web service URI.</xs:documentation>
                  </xs:annotation>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="language" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Programming language.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="val" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Script contents.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ScriptCode.NumType">
      <xs:annotation>
         <xs:documentation>Programming code or pseudocode that describes a calculation.  The code returns a value of the data type required by the parent Response field.  To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent.  It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs.  The @ type attribute may be used to distinguish between them.  An Extension may be used instead of or along with an Expression and Parameters list.  Expressions may populate Responses that are set to @readOnly = "true" to ensure that all responses are calculated and not latered by the user.  Alternatively, the user may change a value created by (or instead of) the Expression.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence minOccurs="0">
               <xs:element maxOccurs="unbounded" minOccurs="0" name="Parameter" type="ParameterItemType111">
                  <xs:annotation>
                     <xs:documentation>Parameters are named FormDesign items which have property values that need to be supplied to a scripted function or a web service URI.</xs:documentation>
                  </xs:annotation>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="language" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Programming language.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="val" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Script contents.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ScriptCode.BoolType">
      <xs:annotation>
         <xs:documentation>Programming code or pseudocode that describes a calculation.  The code returns a value of the data type required by the parent Response field.  To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent.  It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs.  The @ type attribute may be used to distinguish between them.  An Extension may be used instead of or along with an Expression and Parameters list.  Expressions may populate Responses that are set to @readOnly = "true" to ensure that all responses are calculated and not latered by the user.  Alternatively, the user may change a value created by (or instead of) the Expression.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence minOccurs="0">
               <xs:element maxOccurs="unbounded" minOccurs="0" name="Parameter" type="ParameterItemType111">
                  <xs:annotation>
                     <xs:documentation>Parameters are named FormDesign items which have property values that need to be supplied to a scripted function or a web service URI.</xs:documentation>
                  </xs:annotation>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="language" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Programming language.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="val" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Script contents.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ScriptCode.StrType">
      <xs:annotation>
         <xs:documentation>Programming code or pseudocode that describes a calculation.  The code returns a value of the data type required by the parent Response field.  To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent.  It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs.  The @ type attribute may be used to distinguish between them.  An Extension may be used instead of or along with an Expression and Parameters list.  Expressions may populate Responses that are set to @readOnly = "true" to ensure that all responses are calculated and not latered by the user.  Alternatively, the user may change a value created by (or instead of) the Expression.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:sequence minOccurs="0">
               <xs:element maxOccurs="unbounded" minOccurs="0" name="Parameter" type="ParameterItemType111">
                  <xs:annotation>
                     <xs:documentation>Parameters are named FormDesign items which have property values that need to be supplied to a scripted function or a web service URI.</xs:documentation>
                  </xs:annotation>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="language" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Programming language.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="val" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Script contents.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="ScriptCode.DateTimeType">
      <xs:annotation>
         <xs:documentation>Programming code or pseudocode that describes a calculation.  The code returns a value of the data type required by the parent Response field.  To assist with enabling the code in the form, the referenced form items and properties should be referenced by @name under the parameters elemeent.  It is possible to add mulitple calculation expressions to produce equivalent results using different programming languages and URIs.  The @ type attribute may be used to distinguish between them.  An Extension may be used instead of or along with an Expression and Parameters list.  Expressions may populate Responses that are set to @readOnly = "true" to ensure that all responses are calculated and not latered by the user.  Alternatively, the user may change a value created by (or instead of) the Expression.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnDateTimeType">
            <xs:sequence minOccurs="0">
               <xs:element maxOccurs="unbounded" minOccurs="0" name="Parameter" type="ParameterItemType111">
                  <xs:annotation>
                     <xs:documentation>Parameters are named FormDesign items which have property values that need to be supplied to a scripted function or a web service URI.</xs:documentation>
                  </xs:annotation>
               </xs:element>
            </xs:sequence>
            <xs:attribute name="language" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Programming language.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="val" type="xs:string">
               <xs:annotation>
                  <xs:documentation>Script contents.</xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:element name="___AlgorithmHelpers___" abstract="true" final="#all" block="#all"/>
   <xs:complexType name="CompareType">
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="LHS_Expression" type="Any.Functions.AnyType"/>
               <xs:element name="RHS_Expression" type="Any.Functions.AnyType"/>
            </xs:sequence>
            <xs:attribute ref="CompareOpEnum"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="InListType">
      <xs:annotation>
         <xs:documentation>Determine if a supplied target value is a member of a supplied space-delimited list (@list) of numeric or string values.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="Expression" type="Any.Functions.AnyType"/>
               <xs:element name="List" type="Any.Functions.ListType"/>
            </xs:sequence>
            <xs:attribute ref="not"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="BetweenType">
      <xs:annotation>
         <xs:documentation>Determine if a supplied target value is between a min and a max values of a compatible datatype</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnBoolType">
            <xs:sequence>
               <xs:element name="Expression" type="Any.Functions.AnyType"/>
               <xs:element name="IsBetween" type="IsBetweenType"> </xs:element>
            </xs:sequence>
            <xs:attribute ref="not"/>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="IsBetweenType">
      <xs:complexContent>
         <xs:extension base="ExtensionBaseType">
            <xs:sequence>
               <xs:element name="Min_Expression">
                  <xs:complexType>
                     <xs:complexContent>
                        <xs:extension base="Any.Functions.AnyType">
                           <xs:attribute name="boundry">
                              <xs:simpleType>
                                 <xs:restriction base="xs:string">
                                    <xs:enumeration value="Inclusive"/>
                                    <xs:enumeration value="Exclusive"/>
                                 </xs:restriction>
                              </xs:simpleType>
                           </xs:attribute>
                        </xs:extension>
                     </xs:complexContent>
                  </xs:complexType>
               </xs:element>
               <xs:element name="Max_Expression">
                  <xs:complexType>
                     <xs:complexContent>
                        <xs:extension base="Any.Functions.AnyType">
                           <xs:attribute name="boundry">
                              <xs:simpleType>
                                 <xs:restriction base="xs:string">
                                    <xs:enumeration value="Inclusive"/>
                                    <xs:enumeration value="Exclusive"/>
                                 </xs:restriction>
                              </xs:simpleType>
                           </xs:attribute>
                        </xs:extension>
                     </xs:complexContent>
                  </xs:complexType>
               </xs:element>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:attribute name="CompareOpEnum">
      <xs:annotation>
         <xs:documentation>Operator for comparisons that result in a Boolean value.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
         <xs:restriction base="xs:string">
            <xs:enumeration value="EQ"/>
            <xs:enumeration value="GT"/>
            <xs:enumeration value="GTE"/>
            <xs:enumeration value="LT"/>
            <xs:enumeration value="LTE"/>
            <xs:enumeration value="NE"/>
         </xs:restriction>
      </xs:simpleType>
   </xs:attribute>
   <xs:complexType name="SetAttrValueType">
      <xs:complexContent>
         <xs:extension base="Any.Functions.AnyType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:complexType name="GetAttrValueType">
      <xs:annotation>
         <xs:documentation>Set or get the value of a specific attribute on a named element.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="GetStrAttrValueType">
      <xs:annotation>
         <xs:documentation>Set or get the value of a specific attribute on a named element.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnStrType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="GetNumAttrValueType">
      <xs:annotation>
         <xs:documentation>Set or get the value of a specific attribute on a named element.</xs:documentation>
      </xs:annotation>
      <xs:complexContent>
         <xs:extension base="ReturnNumType">
            <xs:sequence>
               <xs:element name="Target" type="ItemNameAttributeType"/>
            </xs:sequence>
         </xs:extension>
      </xs:complexContent>
   </xs:complexType>
   <xs:attributeGroup name="GetSetPropertyValue000">
      <xs:attribute name="propertyName" type="xs:NCName" use="required">
         <xs:annotation>
            <xs:documentation>The @name attribute of the referenced element.</xs:documentation>
         </xs:annotation>
      </xs:attribute>
      <xs:attribute ref="dataTypeListAll"/>
   </xs:attributeGroup>
</xs:schema>
