<?xml version="1.0" encoding="UTF-8"?>

<xs:schema elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema"
	targetNamespace="urn:ihe:qrph:sdc:2016" xmlns="urn:ihe:qrph:sdc:2016" version="3.0">
	<!-- rlm:8/23/2017 Changes to support SDC rules -->
	<xs:include schemaLocation="SDCExpressions.xsd"/>

	<xs:element name="FormDesign" type="FormDesignType">
		<xs:annotation>
			<xs:documentation>Root element of this Schema</xs:documentation>
		</xs:annotation>
		<xs:unique name="uniqueID" xmlns="urn:ihe:qrph:sdc:2016">
			<xs:selector xpath=".//*"/>
			<xs:field xpath="@ID"/>
		</xs:unique>
	</xs:element>
	<xs:element name="DemogFormDesign" type="FormDesignType">
		<xs:annotation>
			<xs:documentation>Root element of this Schema for a demographic form</xs:documentation>
		</xs:annotation>
		<xs:unique name="uniqueID_Demog" xmlns="urn:ihe:qrph:sdc:2016">
			<xs:selector xpath=".//*"/>
			<xs:field xpath="@ID"/>
		</xs:unique>
	</xs:element>
	<xs:element name="DataElement" type="DataElementType">
		<xs:annotation>
			<xs:documentation>Root element of this Schema for a Data Element</xs:documentation>
		</xs:annotation>
		<xs:unique name="uniqueID_DE" xmlns="urn:ihe:qrph:sdc:2016">
			<xs:selector xpath=".//*"/>
			<xs:field xpath="@ID"/>
		</xs:unique>
	</xs:element>
	<xs:group name="ChildElementsGroup">
		<xs:choice>
			<xs:annotation>
				<xs:documentation>IdentifiedExtensionType choices</xs:documentation>
			</xs:annotation>
			<xs:element minOccurs="0" name="Section" type="SectionItemType">
				<xs:annotation>
					<xs:documentation>A Section is a grouper for other types of
						objects.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element minOccurs="0" name="Question" type="QuestionItemType">
				<xs:annotation>
					<xs:documentation>A Question may take 3 basic forms: QS: single-select answer
						response QM: multi-select - more than one answer may be selected QF: fill-in
						response; no answer choices are present for selection QS and QM are
						associated with a ListField of answer choices. The ListField may contain a
						List with ListItems (expicitly stated answer choices), or it may contain a
						LookupEndpoint field that populates the list from a web service. See
						@maxSelections on ListField for information on distinguishing QS from QM. QF
						is identified by the presence of a ResponseField child, which describes how
						the fill-in response should be recorded. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element minOccurs="0" name="DisplayedItem" type="DisplayedType">
				<xs:annotation>
					<xs:documentation>The DisplayedItem contains title, Blob (Binary Large Object),
						and/or Link content, and may also include Contacts and CodedValues that
						relate to the Note/Blob/Link objects. DisplayedItems may be interspersed
						with other MainItems or ListItem nodes. The parent items may be Section,
						Question, and ListItem. However, DisplayedItems are not "attached" to any
						specific item Section, Question, or ListItem. Instead they are free-floating
						items that can appear anywhere on a form, such as between ListItem
						nodes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element minOccurs="0" name="ButtonAction" type="ButtonItemType">
				<xs:annotation>
					<xs:documentation>A Button is a visible area that can be selected ("clicked") to
						trigger event code to perform an action. It is ordinarily implemented with
						an image that looks like a rectangular button object, but a button can look
						like anything.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element minOccurs="0" name="InjectForm" type="InjectFormType">
				<xs:annotation>
					<xs:documentation>InjectForm is a link to a form (or portion of a form) that is
						imported into the current form at specific sites.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:complexType name="DataElementType">
		<xs:complexContent>
			<xs:extension base="IdentifiedExtensionType">
				<xs:group maxOccurs="unbounded" ref="ChildElementsGroup"/>
				<xs:attribute name="lineage" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>NEW: A text identifier that is used to group multiple
							versions of a single DE. The lineage is constant for all versions of a
							single kind of DE. When appended to @baseURI, it can be used to retrieve
							all versions of one particular DE.</xs:documentation>

					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="version" type="xs:string" use="required">
					<xs:annotation>

						<xs:documentation>NEW: @version contains the version text for the current
							DE. It is designed to be used in conjuction with @baseURI and
							@lineage.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="versionPrev" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>NEW: Identify the immediate previous version of the
							current DE. The format is the same as version. The primary role of this
							optional attribute is to allow automated comparisons between a current
							DE and the immediate previous DE version. This is often helpful when
							deciding whether to adopt a newer version of a DE. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="fullURI" type="URI_Atype" use="required">
					<xs:annotation>

						<xs:documentation>NEW: The full URI that uniquely identifies the current
							DE.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="basedOnURI" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>NEW: URI used to identify the DE that that this DE is
							based upon. In most cases, this should be a standard form that is
							modified and/or extended by the current DE. The current template reuses
							the basedOn IDs whenever the question/answer/semantic context is
							identical to the original.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string">
					<xs:annotation>
						<xs:documentation>NEW: filename to use when the current FormDesign instance
							is saved as a file. For forms containing responses, the filename may
							include the formInstanceVersionURI, but the naming convention may be
							use-case-specific.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FormDesignType">
		<xs:annotation>
			<xs:documentation>Start here. This is the top level of the SDCFormDesign object model.
				It represents the definition for the information content of a single data-entry
				form. </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="IdentifiedExtensionType">
				<xs:sequence minOccurs="0">
					<xs:element minOccurs="0" name="BeforeLoadForm" type="EventType">
						<xs:annotation>
							<xs:documentation>NEW: This event is fired before the page is loaded
								into memory, and before stored form data is loaded. It may be used,
								e.g., for authentication, to retrieve/prepare stored data, and/or to
								control form rendering according to user
								preferences.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element minOccurs="0" name="BeforeLoadData" type="EventType">
						<xs:annotation>
							<xs:documentation>NEW: This event is fired after the page is loaded into
								memory, before stored form data is loaded, and before the form is
								visible. For example, It may be used to determine the data to be
								loaded and to perform the data loading.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element minOccurs="0" name="BeforeShowForm" type="EventType">
						<xs:annotation>
							<xs:documentation>NEW: This event is fired after the page is loaded is
								memory, after the data is loaded into the form, but before the form
								is displayed. It may be used to perform form activities that are
								controlled by the loaded data.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element minOccurs="0" name="BeforeDataSubmit" type="EventType"/>
					<xs:element minOccurs="0" name="BeforeCloseForm" type="EventType"/>
					<xs:element minOccurs="0" name="OnEvent" maxOccurs="unbounded" type="OnEventType">
					<xs:element
						minOccurs="0"
						name="OnEvent"
						maxOccurs="unbounded"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType">
					<xs:element
						minOccurs="0"
						name="OnEvent"
						maxOccurs="unbounded"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType">
					<xs:element
						minOccurs="0"
						name="OnEvent"
						maxOccurs="unbounded"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType">
						<xs:annotation>
							<xs:documentation>Generic event handler - eventName must be
								specified.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Header" type="SectionItemType" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>Optional Section that stays at the top of a
								form.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Body" type="SectionItemType" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>Main Section of form</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Footer" type="SectionItemType" minOccurs="0" maxOccurs="1">
						<xs:annotation>
							<xs:documentation>Optional Section that stays at the bottom of a
								form.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element minOccurs="0" name="Rules" type="RulesType"> </xs:element>
				</xs:sequence>
				<xs:attribute name="lineage" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>A string identifier that is used to group multiple
							versions of a single form. The lineage is constant for all versions of a
							single kind of form. When appended to baseURI, it can be used to
							retrieve all versions of one particular form. Example:
							@lineage="Lung.Bmk.227"</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="version" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>@version contains the version text for the current form.
							It is designed to be used in conjunction with @baseURI and @lineage.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="versionPrev" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation>@versionPrev identifies the immediate previous version of
							the current FDF. The format is the same as version. The primary role of
							this optional attribute is to allow automated comparisons between a
							current FDF and the immediate previous FDF version. This is often
							helpful when deciding whether to adopt a newer version of an FDF.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="fullURI" type="URI_Atype" use="required">
					<xs:annotation>
						<xs:documentation>The full URI that uniquely identifies the current form. It
							is created by concatenating @baseURI + lineage + version. Each of the
							components is separated by a single forward slash.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="filename" type="xs:string">
					<xs:annotation>
						<xs:documentation>@filename is the filename of the FDF when is saved to a
							file storage device (e.g., a disk or USB drive). The filename appears
							inside the FDF XML to help ensure the identity of the FDF content in
							case the saved filename (on a disk drive, etc.) has been changed for any
							reason. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="formTitle" type="xs:string">
					<xs:annotation>
						<xs:documentation>@formTitle is a human readable title for display when
							choosing forms. Added 4/27/16</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="basedOnURI" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>@basedOnURI is a URI that identifies the SDC form that
							that the current FDF is based upon. In most cases, this should be a
							standard SDC form that is modified and/or extended by the current FDF.
							Itâ€™s best to avoid using prefixes like "http://" or "https://" because
							these can occasionally cause XML validation errors when used in a
							URI-typed field. The URI format should be the same format used in
							fullURI, which is patterned after the SDC web service API.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="instanceID" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation>@instanceID is unique string (e.g., a GUID) used to
							identify a unique instance of a form, such as a form used during a
							single patient encounter. The @instanceID is used to track saved form
							responses across time and across multiple episodes of editing by
							end-users. This string does not change for each edit session of a form
							or package instance. The @instanceID is required in an FDF-R; It is not
							allowed in an FDF. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="instanceVersion" type="xs:dateTime" use="optional">
					<xs:annotation>
						<xs:documentation>@instanceVersion Timestamp is used to identify a unique instance of a form.
							Used for tracking form responses across time and across multiple
							episodes of editing by end-users. This field must change for each edit
							session of a form instance. The instanceVersion is required in an FDF-R;
							It is not allowed in an FDF. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="instanceVersionURI" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>NEW: Globally-unique URI used to identify a unique
							instance of a form's saved responses. It is used for tracking form
							responses across time and across multiple episodes of editing by
							end-users. The instanceVersionURI must change for each edit/save session
							of a form instance (defined by instanceVersion). The instanceVersionURI
							should be formatted similarly to the fullURI but must include values for
							instanceID and instanceVersion. The instanceVersion value is the release
							date/time for the new version, in W3C datetime format. An example
							instanceVersionURI is:
							instanceVersionURI="_baseURI=cap.org&amp;_lineage=Lung.Bmk.227&amp;_version=1.001.011.RC1
							&amp;_instanceID=Abc1dee2fg987&amp;_instanceVersion=2019-07-16T19:20:30+01:00&amp;_docType=sdcFDFR
							" It is possible to create a shorter URI without the _baseURI, _lineage
							and _version parameters, as long as the URI is able to globally and
							uniquely identify and retrieve the instance and version of the FDF-R
							that was transmitted:
							instanceVersionURI="_instanceID=Abc1dee2fg987&amp;_instanceVersion=2019-07-16T19:20:30+01:00&amp;_docType=sdcFDFR"
							Note that the FR webservice endpoint URI is not provided in the
							instanceVersionURI. The FR endpoint and its security settings may be
							found in the SDC Package that contains the FDF-R, at
							SDCPackage/SubmissionRule. An FR may also be provided in a custom FDF
							Property if desired. The docType for instanceVersionURI is sdcFDFR. The
							specific order of components shown in the URI examples is not required,
							but the component order shown above is suggested for consistency and
							readability. The instanceVersionURI is not required, and is not allowed
							in an FDF. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="instanceVersionPrev" type="xs:dateTime" use="optional">
					<xs:annotation>
						<xs:restriction base="xs:string">
							<xs:enumeration value="inProcess"/>
							<xs:enumeration value="preliminary"/>
							<xs:enumeration value="approved"/>
							<xs:enumeration value="cancelled"/>
							<xs:enumeration value="retracted"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="completionStatus">
					<xs:annotation>
						<xs:restriction
							base="xs:string">
							<xs:enumeration
								value="inProcess"/>
							<xs:enumeration
								value="preliminary"/>
							<xs:enumeration
								value="approved"/>
							<xs:enumeration
								value="cancelled"/>
							<xs:enumeration
								value="retracted"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute
					name="completionStatus">
					<xs:annotation>
						<xs:documentation>The extent to which a report contains all of the requested
							information pending: no information is yet available incomplete: some
							requested information is not yet available complete: all information is
							available in the requested report</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="pending"/>
							<xs:enumeration value="incomplete"/>
							<xs:enumeration value="complete"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attributeGroup ref="ResponseAttributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ChildItemsType">
		<xs:annotation>
			<xs:documentation>ChildItems have descendants that are of type DisplayedType. They may
				include primary items of type SectionType, QuestionType, InjectFormType,
				DisplayedType and ButtonType, in any order. The ChildItem separates new child
				primary items from elements and attributes that are sub-parts of the parent primary
				item.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:group maxOccurs="unbounded" ref="ChildElementsGroup"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="InjectFormType">
		<xs:annotation>
			<xs:documentation>CHANGED: This type represents a form or portion of a form that is
				imported into the current form at a specific location. It allows the composition of
				forms from other forms or parts of other forms. In practice, using an injected
				section will requiresome or all of the injected FormDesignXML to be injected under
				this the InjectForm element. For that reason, the schema supports those elements to
				appear inline. However, in a "raw" form (not yet filled out), the FormDesign element
				would generally be empty; only the top-level InjectFormType attributes would be used
				to point to the parts to be later injected. Form parts to be injected are specified
				by packageID, not FormID. This allows an injected form to be assocaited with helper
				files, or to return previosuly completed form parts containing responses.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="IdentifiedExtensionType">
				<!--Feb 03, 222: Changed minOccurs from 1 to 0 to allow SDC templates to reference an injectable part, but are not yet populated with an instantiated injection.-->
				<xs:choice minOccurs="0">
					<xs:element name="Section" type="SectionItemType"/>
					<xs:element name="Question" type="QuestionItemType"/>
					<xs:element name="FormDesign" type="FormDesignType"/>
				</xs:choice>
				<xs:attribute name="InjectionSourceURI" type="URI_Atype" use="required">
					<xs:annotation>
						<xs:documentation>NEW (2/24/2022): The source of the SDC FormDesign, Section or Question to inject
The suggested form of the URI is:

serverURI + \fullURI for the FDF (as described in the SDC Technical Reference Guide [TRG])
Retrieves the latest package version with FDF responses (contains the latest FDF-R content)
-OR-
serverURI +\instanceVersionURI for the FDF-R (as described in the TRG)
Retrieves a specific package version with FDF responses  (contains the FDF-R content from a specific point in time)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="rootItemID" type="URI_Atype" use="required">
					<xs:annotation>
						<xs:documentation>The rootItemID is the ID of the form or form part that
							will be injected. It must point to a valid FormDesign, Section or
							Question element. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="serverURI" type="URI_Atype">
			<xs:extension base="CallFuncActionType">
				<xs:sequence maxOccurs="1">
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ResponseValue" type="CodingType">
				ListFieldType.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
<<<<<<<<< Temporary merge branch 1
			<xs:extension base="CallFuncType">
				<xs:sequence maxOccurs="1">
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ResponseValue"
=========
			<xs:extension
				base="CallFuncActionType">
				<xs:sequence
					maxOccurs="1">
					<xs:element
						maxOccurs="unbounded"
						minOccurs="0"
						name="ResponseValue"
>>>>>>>>> Temporary merge branch 2
						type="CodingType">
						<xs:annotation>
							<xs:documentation>The user's response to the lookup list. The response
								is recorded as a coding, terminology, classification, keyword, or
								local value. Multiple selections from the lookup list may be
								allowed.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="includesHeaderRow" type="xs:boolean" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ListItemType">
		<xs:annotation>
			<xs:documentation>ListItem elements represent answer choices that may appear under a
				Question.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ListItemBaseType">
				<xs:choice minOccurs="0">
					<xs:element name="ChildItems" type="ChildItemsType" minOccurs="0"/>
				</xs:choice>
			</xs:extension>
					<xs:element name="OnSelect" maxOccurs="unbounded" minOccurs="0" type="EventType"> </xs:element>
					<xs:element name="OnDeselect" maxOccurs="unbounded" minOccurs="0" type="EventType"> </xs:element>
					<xs:element name="SelectIf" minOccurs="0" type="PredGuardType"> </xs:element>
					<xs:element name="DeselectIf" minOccurs="0" type="PredGuardType"> </xs:element>
						name="OnSelect"
						maxOccurs="unbounded"
						minOccurs="0"
						type="EventType"> </xs:element>
					<xs:element
						name="OnDeselect"
						maxOccurs="unbounded"
						minOccurs="0"
						type="EventType"> </xs:element>
					<xs:element
						name="SelectIf"
						minOccurs="0"
						type="PredGuardType"> </xs:element>
					<xs:element
						name="DeselectIf"
						minOccurs="0"
						type="PredGuardType"> </xs:element>
>>>>>>>>> Temporary merge branch 2
				</xs:sequence>
				<xs:attribute default="false" name="selected" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Represents the default value of the ListItem in the
							FormDesign template, or the user's response in selecting one or more
							ListItems. If @multiSelect='false' on ListField then only one item may
							be selected.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="false" name="selectionDisablesChildren" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If set to true, then selecting this ListItem must
							deactivate all descendant parts of the form, and ignore any user-entered
							values in the deactivated part. Deselecting the ListItem should
							reactivate the descendant items in their state at the time the items
							were deactivated. If items are disabled, then any data stored in the
							disabled questions should be removed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="selectionActivatesItems" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>NEW Selecting the current ListItem will enable the named
							items in this attribute's content. Prefixing any named with a hyphen (-)
							will reverse the above behaviour (i.e., the named items will be
							disabled). Unselecting the ListItem will reverse this behaviour.
							Prefixing the name with a tilde (~) will supress this reversal behavior.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="selectionSelectsListItems" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>NEW Selecting the current ListItem will select the named
							ListItems in this attribute's content. Prefixing any named with a hyphen
							(-) will reverse the above behaviour. Unselecting the ListItem will
							reverse this behaviour. Prefixing the name with a tilde (~) will
							suppress this reversal behavior. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="false" name="selectionDeselectsSiblings" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If the ancestor ListField has @multiselect = 'true', then
							selecting this ListItem should de-select all other ListItem (sibling)
							nodes except the current one.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="false" name="omitWhenSelected" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If @omitWhenSelected is set to true, then the question and
							its response(s) should not be present in a typical report derived from
							this template. This attribute is usually set to true when the answer
							choice is used to control form behavior (e.g., skip logic), or when the
							question provides unhelpful "negative" information about actions that
							did not occur or were not performed, or things that were not observed or
							could not be assessed. If @omitWhenSelectedset is false (default) then
							the question and its response(s) should appear in the report. Added
							11/29/15 to replace @reportAction</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attributeGroup ref="ResponseReportingAttributes"/>
				<xs:attribute name="associatedValue" type="xs:string">
					<xs:annotation>
						<xs:documentation>A typed value (e.g., an integer) that is uniquely
							associated with a ListItem. An example is the integer 10 for a ListItem
							with title that reads "10 o'clock". Typically these values are set to be
							used in calculations or other algorithms. In general, they can be
							treated something like a user-entered response on a the
							ListItemResponseField of a selected ListItem. This field should not be
							used for terminologies or local codes. The CodedValue type should be
							used for these kinds of metadata. This field should also not be used
							other properties such as translations, usage, etc. The data type shoudl
							be specified in @AssociatedValueType </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="associatedValueType" type="DataTypeAll_StypeEnum">
					<xs:annotation>
						<xs:documentation>The data type of @AssociatedValue. Default is
							string.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ListType">
		<xs:annotation>
			<xs:documentation>This type represents a list of specified answer choices. CHANGED
				9/20/2016: Fix for serialization error which aggregated all DisplayedItems at the
				top of the ListItems. A Schematron (or similar validation tool) will be required to
				ensure that at least 2 ListItems are present for single-select questions, and one
				ListItem for multi-select questions. </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:choice maxOccurs="unbounded">
					<xs:element name="DisplayedItem" type="DisplayedType"/>
					<xs:element name="ListItem" type="ListItemType" minOccurs="1" maxOccurs="1"/>
				</xs:choice>
			</xs:extension>
					<xs:element maxOccurs="1" minOccurs="0" name="DefaultCodeSystem" type="CodeSystemType">
			<xs:extension base="ExtensionBaseType">
				<xs:sequence>
					<xs:element minOccurs="0" name="ListHeaderText" type="RichTextType">
						<xs:annotation>
							<xs:documentation>The header row for a set of list items. If the list
								has more than one column, the column text is separated by the
								colTextDelimiter.</xs:documentation>
						</xs:annotation>
					</xs:element>
<<<<<<<<< Temporary merge branch 1
					<xs:element maxOccurs="1" minOccurs="0" name="DefaultCodeSystem"
=========
					<xs:element
						maxOccurs="1"
						minOccurs="0"
						name="DefaultCodeSystem"
>>>>>>>>> Temporary merge branch 2
						type="CodeSystemType">
						<xs:annotation>
							<xs:documentation>If coded values are used for items in a List
						<xs:element name="LookupEndPoint" minOccurs="1" maxOccurs="1" type="LookupEndPointType">
						<xs:element name="List" type="ListType">
							<xs:annotation>
								<xs:documentation>List refers to a set of possible answer choices
									for the user to select. Child DisplayedItems may be interspersed
									with Child ListItems. At least one ListItem must be present for
									a multi-select question, and at least two ListItems must pre
									present for single-select questions.</xs:documentation>
							</xs:annotation>
						</xs:element>
<<<<<<<<< Temporary merge branch 1
					<xs:element maxOccurs="unbounded" minOccurs="0" name="IllegalListItemPairings"
									explicit set of ListItem nodes specified in the FormDesign XML.
									The endpoint must return a list separated into individual list
									items by the @colTextDelimiter value specified in the parent
					<xs:element minOccurs="0" name="AfterChange" maxOccurs="unbounded" type="EventType">
						type="RuleSelectionTestType"/>
					<xs:element maxOccurs="unbounded" minOccurs="0"
						name="IllegalCoSelectedListItems" type="RuleSingleSelectionSetsType"/>
					<xs:element minOccurs="0" name="AfterChange" maxOccurs="unbounded"
=========
					<xs:element maxOccurs="unbounded" minOccurs="0" name="OnEvent" type="OnEventType"/>
						minOccurs="0"
						name="OnEvent"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType"/>
						name="AfterChange"
						maxOccurs="unbounded"
>>>>>>>>> Temporary merge branch 2
						type="EventType">
						<xs:annotation>
							<xs:documentation>Event that occurs after List Field selections are
								changed.</xs:documentation>
						</xs:annotation>
					</xs:element>
<<<<<<<<< Temporary merge branch 1
					<xs:element maxOccurs="unbounded" minOccurs="0" name="OnEvent"
=========
					<xs:element
						maxOccurs="unbounded"
						minOccurs="0"
						name="OnEvent"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType"/>
				</xs:sequence>
				<xs:attribute default="|" name="colTextDelimiter">
					<xs:annotation>
						<xs:documentation>Character in the DisplayText that separates the columns
							and rows in a single or multi-column list.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:length value="1"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute default="1" name="numCols" type="xs:unsignedByte">
					<xs:annotation>
						<xs:documentation>Number of columns in the list</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="1" name="storedCol" type="xs:unsignedByte">
					<xs:annotation>
						<xs:documentation>Determines which column of the list is stored in a
							database. This list is one-based.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="1" name="minSelections">
					<xs:annotation>
						<xs:documentation>Minimum number of answer choices (list items) that must be
							selected by the user. Default value is 1. NEW: changed minimum value to
							1. Removed: If set to 0, then this question need not be answered by the
							user.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:unsignedShort">
							<xs:minInclusive value="1"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute default="1" name="maxSelections" type="xs:unsignedShort">
					<xs:annotation>
						<xs:documentation>Maximum number of answer choices (list items) that can be
							selected by the user. Must be greater than or equal to minSelections,
							and no larger than the total number of list items. A value of 0
							indicates no limit to the number of selected list items (answers). This
							effectively means that the question is multi-select. (Abbreviated as QM)
							A value of 1 (the default) indicates that the question list is
							single-select. (Abbreviated as QS)</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="true" name="ordered" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If false, then the form implementation may change the
							order of items in the list.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="defaultListItemDataType" type="DataTypeAll_StypeEnum">
					<xs:annotation>
						<xs:documentation>This attribute contains an SDC datatype enumeration. The
							selected value is the datatype of the content for all
							ListItem/@associatedValue content in the current List. It is used
						<xs:element name="Response" type="DataTypes_DEType" minOccurs="1" maxOccurs="1">
	</xs:complexType>
	<xs:complexType name="ResponseFieldType">
		<xs:annotation>
			<xs:documentation>This type is a template for a data entry field that accepts entries
				(responses or answers) of any data type, including text, numbers, dates, and Base 64
				- encoded blobs (images, sounds, video, other binary formats, etc.). This type
				cannot contain ListItems, but it may be a child of a Question or a
				ListItem.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:sequence>
					<xs:sequence>
<<<<<<<<< Temporary merge branch 1
						<xs:element name="Response" type="DataTypes_DEType" minOccurs="1"
=========
						<xs:element
					<xs:element name="TextAfterResponse" type="RichTextType" minOccurs="0" maxOccurs="1">
						<xs:choice minOccurs="0">
							<xs:element name="CallSetValue" type="CallFuncActionType">
								<xs:annotation>
									<xs:documentation>NEW</xs:documentation>
								</xs:annotation>
							</xs:element>
							<xs:element name="SetValue" type="ScriptCodeAnyType">
								<xs:annotation>
									<xs:documentation>NEW</xs:documentation>
								</xs:annotation>
							</xs:element>
					<xs:element maxOccurs="unbounded" name="AfterChange" type="EventType" minOccurs="0">
>>>>>>>>> Temporary merge branch 2
						maxOccurs="1">
						<xs:annotation>
							<xs:documentation>TextAfterResponse is fixed text that appears after (to
								the right of) the user's response on the data entry form. This may
								be text for units such as "mm", "cm", etc.</xs:documentation>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="OnEvent" type="OnEventType"/>
=========
					<xs:element
						maxOccurs="unbounded"
						name="AfterChange"
						type="EventType"
>>>>>>>>> Temporary merge branch 2
						minOccurs="0">
						<xs:annotation>
							<xs:documentation>Event that occurs after the Response value is changed,
								usually fired after a user leaves the Response
								field.</xs:documentation>
						</xs:annotation>
					</xs:element>
<<<<<<<<< Temporary merge branch 1
					<xs:element maxOccurs="unbounded" minOccurs="0" name="OnEvent"
=========
					<xs:element
						maxOccurs="unbounded"
						minOccurs="0"
						name="OnEvent"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:attributeGroup name="ResponseAttributes">
		<xs:attribute name="changedData" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Identifies existence of data that has been changed in the current
					instance of package/form/section/question compared to the previous instance of
					the package/form/section/question</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="newData" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Identifies existence of data that is new to the current instance
					of package, form, section, or question compared to the previous instance of the
					package, form, section, or question</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="ResponseReportingAttributes">
		<xs:annotation>
			<xs:documentation>Used to extend identified items (Section, Question, ListItem) for
				nested/repeating responses in reports and data transmissions.</xs:documentation>
		</xs:annotation>
		<xs:attribute default="0" name="repeat" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>For repeating questions and sections, @repeat represents the
					repeat ordinality, starting with 0. 0 indicates the original Question or
					Section, not a repeated one. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="instanceGUID" type="xs:string">
			<xs:annotation>
				<xs:documentation>A globally unique string assigned to a repeating Question or
					Section, Injected Form, or any selected answer ListItem. This attribute's value
					is assigned at the time that answers are entered into a form, to unambiguously
					identify a single instance among sections or questions, including those that are
					allowed to repeat and nest deeply. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="parentGUID" type="xs:string">
			<xs:annotation>
				<xs:documentation>A globally unique string assigned from a Section, Question,
					ListItem or InjectedForm to the ID of its parent node (S, Q, LI or IF). This
					attribute's value is assigned at the time that answers are entered into a form,
					to unambiguously identify a single instance among the above objects, including
					those that are allowed to repeat and nest deeply. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="ListItemResponseFieldType">
		<xs:annotation>
			<xs:documentation>This type represents a place to store a fill-in response associated
				directly with a selected ListItem. The response may be optional or
				required.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ResponseFieldType">
				<xs:attribute name="responseRequired" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>If @responseRequired is set to true, then the appropriate
							text or Blob must be entered in the data-entry field associated with
							this list item.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ButtonItemType">
		<xs:annotation>
			<xs:documentation>The ButtonItem type represents a visual area for a user to click, and
				the click triggers a piece of "Action" code to run inside the form. The ButtonAction
				object may be represented with a visible button object, or some other type of visual
				paradigm. Other types of actions (e.g. key presses in a text field) may be handled
				with the form framework's event model.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DisplayedType">
				<xs:choice>
					<xs:element minOccurs="0" name="OnClick" type="EventType" maxOccurs="unbounded"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SectionItemType">
		<xs:annotation>
			<xs:documentation>The Section is a grouper for all other types of objects. It may have a
				distinctive visual display (e.g. a box containing other displayed objects), and it
				may be used to treat Section descendants as a unit for special handling, such as
				hiding and showing. </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SectionBaseType">
				<xs:choice minOccurs="0">
					<xs:annotation>
						<xs:documentation>MainNodes choices</xs:documentation>
					</xs:annotation>
					<xs:element name="ChildItems" type="ChildItemsType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Child items are of type DisplayedType. They may
								include items of type SectionType, QuestionType, InjectFormType,
								DisplayedType and ButtonType, in any order.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SectionBaseType" abstract="true">
		<xs:annotation>
			<xs:documentation>This base item is the same as the SectionItemType, except it lacks the
				recursion created by the inclusion of MainItems sub-group.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RepeatingType">
				<xs:attribute default="true" name="ordered" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If false, then the form implementation may change the
							order of items in the section.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attributeGroup ref="ResponseAttributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QuestionItemType">
		<xs:annotation>
					<xs:element name="ResponseField" type="ResponseFieldType" minOccurs="1" maxOccurs="1"/>
					<xs:element name="ListField" minOccurs="1" maxOccurs="1" type="ListFieldType"> </xs:element>
			<xs:extension base="RepeatingType">
				<xs:choice maxOccurs="1">
					<xs:annotation>
						<xs:documentation>Choice (ResponseField, ListField)</xs:documentation>
					</xs:annotation>
<<<<<<<<< Temporary merge branch 1
					<xs:element name="ResponseField" type="ResponseFieldType" minOccurs="1"
						maxOccurs="1"/>
					<xs:element name="ListField" minOccurs="1" maxOccurs="1" type="ListFieldType">
					</xs:element>
=========
					<xs:element
						name="ResponseField"
						type="ResponseFieldType"
						minOccurs="1"
						maxOccurs="1"/>
					<xs:element
						name="ListField"
						minOccurs="1"
						maxOccurs="1"
						type="ListFieldType"> </xs:element>
>>>>>>>>> Temporary merge branch 2
				</xs:choice>
				<xs:attribute default="false" name="readOnly" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If @readOnly is set to true, the this field may not be
							edited by the user, and any default values set by template should be
							considered part of the stored data set responses, and transmitted by the
							SubmitForm transaction.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attributeGroup ref="ResponseAttributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RepeatingType" abstract="true">
		<xs:annotation>
			<xs:documentation>This type presents any display objects that may be repeated based upon
				on the user's interaction with the form objects. Items derived from this type
				include Sections and Questions.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DisplayedType">
				<xs:attribute name="minCard" type="xs:unsignedShort" default="1">
					<xs:annotation>
						<xs:documentation>@minCard is the minimum number of repetitions allowed for
							a section or question. The default value is 1, indicating that the user
							must answer any question(s) that has this attribute set. If @minCard is
							set to 0, then the item and all descendent questions are optional to
							answer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="maxCard" default="1" type="xs:unsignedShort">
					<xs:annotation>
						<xs:documentation>@maxCard is the maximum number of repetitions allowed for
							a section or question. The default value is 1, indicating that the
							section or question cannot be repeated on the data entry form. A value
							of 0 indicates that the number of repeats is unlimited. If @maxCard is
							not 0, then Must be greater than or equal to minCard.
					<xs:element name="BlobContent" type="BlobType" minOccurs="0" maxOccurs="unbounded">
			<xs:documentation>This type represents any object that is designed to have a visual
				presence on a form, e.g., Sections, Questions, ListItems, Notes and Blobs. (Other
				items not inheriting this type may use an optional styleClass
				attribute.)</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
					<xs:element maxOccurs="unbounded" name="Contact" type="ContactType" minOccurs="0">
=========
					<xs:element
						name="BlobContent"
						type="BlobType"
						minOccurs="0"
>>>>>>>>> Temporary merge branch 2
					<xs:element maxOccurs="unbounded" minOccurs="0" name="CodedValue" type="CodingType">
=========
					<xs:element
						maxOccurs="unbounded"
						name="Contact"
						type="ContactType"
					<xs:element minOccurs="0" name="OnEnter" type="EventType" maxOccurs="unbounded"/>
					<xs:element minOccurs="0" name="OnExit" type="EventType" maxOccurs="unbounded"/>
					<xs:element minOccurs="0" name="OnEvent" maxOccurs="unbounded" type="OnEventType">
					</xs:element>
<<<<<<<<< Temporary merge branch 1
					<xs:element minOccurs="0" name="OnEnter" type="EventType" maxOccurs="unbounded"/>
					<xs:element minOccurs="0" name="OnExit" type="EventType" maxOccurs="unbounded"/>
					<xs:element minOccurs="0" name="OnEvent" maxOccurs="unbounded"
=========
					<xs:element
						minOccurs="0"
						name="OnEnter"
						type="EventType"
						maxOccurs="unbounded"/>
					<xs:element
						minOccurs="0"
						name="OnExit"
						type="EventType"
						maxOccurs="unbounded"/>
					<xs:element
						minOccurs="0"
						name="OnEvent"
						maxOccurs="unbounded"
>>>>>>>>> Temporary merge branch 2
						type="OnEventType">
						<xs:annotation>
							<xs:documentation>Generic event handler - eventName must be
								specified.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element minOccurs="0" name="ActivateIf" type="PredGuardType">
						<xs:annotation>
							<xs:documentation>Activate the DisplayedType item if the guard
								conditions are met.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element minOccurs="0" name="DeActivateIf" type="PredGuardType">
						<xs:annotation>
							<xs:documentation>DeActivate the DisplayedType item if the guard
								conditions are met.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="title" type="xs:string">
					<xs:annotation>
						<xs:documentation>The primary text to show on the form. Also known as
							"prompt" or "label" or "visibleText" or "caption"</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="true" name="enabled" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Determines whether the user can interact with the
							displayed item when the form is first displayed. All disabled items are
							treated as read-only: they are visible but may not be edited. The
							attribute value is inherited by descendants.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="true" name="visible" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Determines whether the item should be visible on a
							computer screen when the form is first displayed. The attribute value is
							inherited by descendants.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="true" name="mustImplement" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If this attribute is set to "true" (the default), then the
							form implementation must make this item available for use on the form.
							If this attribute is set to "false" on a parent or ancestor item, then
							all child/descendant items inherit this "false" setting, even if they
							have this attribute set to "true." In other words, the child/descendent
							items do not need to be implemented if any parent/ancestor item has this
							attribute set to false. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="True" name="showInReport">
					<xs:annotation>
						<xs:documentation>CHANGED to T/F/Optional If @showInReport on a Question is
							false, then the Question and its ListItems (if any) should not be
							present in a typical report derived from this template. If this
							attribute appears on a ListItem, then the entire question and all
							ListItems should be omitted from the report. If this attribute appears
							on a Section, then the entire Section and all Section contents
							(descendents) should be omitted from the report. If @showInReport
							appears on a DisplayedItem, then the DisplayedItem should be omitted
							from the report. This attribute is usually set to false when a Question
							is used to control form behavior (e.g., skip logic), or when the
							Question provides unhelpful "negative" information about actions that
							did not occur or were not performed, or things that were not
							observed.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="True"/>
							<xs:enumeration value="False"/>
							<xs:enumeration value="Optional"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:attributeGroup name="IfAttributes">
		<xs:attribute name="onlyIf" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>(reversible); If onlyIf is true, then the stipulated Boolean
					actions, which are executed when the If conditions evaluate to true, are
					reversed when the conditions evaluate to false. If onlyIf="true", the target
					items assume the chosen attribute values (e.g., selected, activated) ONLY when
					the action condition(s) are satisfied. If the conditions are not satisfied, then
					all Boolean actions assume the opposite state (e.g., unselected, inactive).
					Manually changing the attributes on the target item (upon which the actions are
					executed) will not affect any attributes in the controlling items. It is
					possible to disable (enabled="false") the target item so that its attributes can
					only be be changed programmatically. The default value is "false" indicating
					that the the rule runs when the "If" condition is "true." The attached action
					will not reverse (be undone) when the "If" condition evaluates to "false."
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="EventType">
		<xs:complexContent>
			<xs:extension base="PredActionType"> </xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OnEventType">
		<xs:annotation>
			<xs:documentation>Add a custom event handler to a form item such as a question, section
				or list item.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="EventType">
				<xs:attribute name="eventName" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActSetAttributeType">
		<xs:annotation>
			<xs:documentation>This type is used to act upon the value of common item attributes. If
				an "act" attribute (a type with the "act" prefix) has no value assigned, it is
				ignored. If it has a value, then that attribute on the target item(s) assume(s) that
				stated value when an attached Boolean condition evaluates to true. The attached
				condition may be an "If" statement or any expression that evaluates to a Boolean
				value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attribute name="targetNames" type="xs:NMTOKENS" use="required">
					<xs:annotation>
						<xs:documentation>The names of the items affected by property
							actions</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actVisible" type="xs:boolean"/>
				<xs:attribute name="actEnable" type="xs:boolean"/>
				<xs:attribute name="actMinCard" type="xs:nonNegativeInteger">
					<xs:annotation>
						<xs:documentation>Controls requirement to answer the question and the
							minimum number of repeats.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actMaxCard" type="xs:nonNegativeInteger">
					<xs:annotation>
						<xs:documentation>Controls requirement to answer the
							question</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actActivate" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Toggle visible and enabled together. Setting this to false
							will de-activate all descendents but will not change their enabled or
							visible properties.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actSelect" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Toggle selection of a List Item; not applicable to other
							items.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actDeleteResponse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Delete any response in a Response field on a question or
							ListItem. Not applicable to other item types.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actReadOnly" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Delete any response in a Response field on a question or
							ListItem. Not applicable to other item types.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actType" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>Set the @type attribute value</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actStyleClass" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>Set the @styleClass attribute value</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actSetTitleText" type="xs:string">
					<xs:annotation>
						<xs:documentation>Set the @title text on an item.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actSetBase64HTML" type="xs:base64Binary">
					<xs:annotation>
						<xs:documentation>Set HTML as base-64-encoded binary</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actSetCode" type="xs:string"/>
				<xs:attribute name="actSetAssociatedValueFromRef" type="xs:string">
					<xs:annotation>
							if applicable. Supply the @name of an element that has a non-null @val
							value of the correct datatype. Null values are
							ignored.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute
					name="actSetAssociatedValueFromRef"
					type="xs:string">
					<xs:annotation>
	<xs:complexType name="ActSetAttrValueScriptType">
						<xs:documentation>Set a @val attribute.  The correct data type must be used if applicable.  Supply the @name of an element that has a non-null @val value of the correct datatype.  Null values are ignored.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="actSetAssociatedValueFromRef" type="xs:string">
					<xs:annotation>
						<xs:documentation>Set @associatedValue attribute of a ListItem.  The correct data type must be used if applicable.  Supply the @name of an element that has a non-null @val value of the correct datatype.  Null values are ignored.</xs:documentation>
=========
						<xs:documentation>Set @associatedValue attribute of a ListItem. The correct
							data type must be used if applicable. Supply the @name of an element
							that has a non-null @val value of the correct datatype. Null values are
							ignored.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActSetBoolAttributeValueCodeType">
		<xs:annotation>
			<xs:documentation>This type is used to act upon the value of common item properties. If
				an "act" property (a property with the "act" prefix) has no value assigned, it is
				ignored. If it has a value, then that property on the target item(s) assume(s) that
				stated value when an attached Boolean condition evaluates to true. The attached
				condition may be an "If" statement or any expression that evaluates to a Boolean
				value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ScriptCodeAnyType">
				<xs:sequence>
					<xs:element name="Target" type="ItemNameAttributeType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
<<<<<<<<< Temporary merge branch 1
	<xs:complexType name="ActSetBoolAttributeValueCode">
=========
	<xs:complexType
		name="ActSetBoolAttributeValueCode">
>>>>>>>>> Temporary merge branch 2
		<xs:annotation>
			<xs:documentation>Sets the value of any named attribute. However, it is primarily
				designed for Response element(s) on a Question or ListItem. The value may be
				determined by a literal value with a defined data type, the value at another named
				Response item, an expression written in a specified scripting or programming
				language, or the value of a named code listed in the same
				template.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ScriptCodeBoolType">
				<xs:attribute name="elementName" type="xs:NCName" use="required">
					<xs:annotation>
					<xs:element maxOccurs="unbounded" name="Message" type="RichTextType"> </xs:element>
				</xs:attribute>
				<xs:attribute name="X_targetNames" type="xs:NMTOKENS" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActShowMessageType">
		<xs:annotation>
			<xs:documentation>Display a message to the form user, triggered by activity within the
				form.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:sequence>
<<<<<<<<< Temporary merge branch 1
					<xs:element maxOccurs="unbounded" name="Message" type="RichTextType">
					</xs:element>
=========
					<xs:element
						maxOccurs="unbounded"
						name="Message"
						type="RichTextType"> </xs:element>
>>>>>>>>> Temporary merge branch 2
				</xs:sequence>
				<xs:attribute name="alertLevel" type="xs:string"/>
				<xs:attribute name="alertType" type="xs:string"/>
				<xs:attribute name="messageType" type="xs:string"/>
				<xs:attribute name="messageCode" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActShowFormType">
		<xs:annotation>
			<xs:documentation>Show an external form to interact with the user.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attribute name="formID" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>This ID represents the form to be
							displayed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="packageID" type="URI_Atype" use="required">
					<xs:annotation>
						<xs:documentation>This ID represents the Package that contains the form to
							be displayed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="displayState" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActSaveResponsesType">
		<xs:annotation>
			<xs:documentation>Save the form's responses to the default persistance layer(s). The
				default format is SDCSubmitForm, but other formats may be defined and
				used.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:sequence>
					<xs:element name="MessageText" type="RichTextType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActShowReportType">
		<xs:annotation>
			<xs:documentation>Show a stored report. The following parameters may be used: reportID:
				indicator of a report definition in SDC format. packageID: retrieve report as a
				package with ancillary information. reportInstanceGUID: retreive 1 or more report
				versions by using a report instance GUID. This may be used in conjunctions with a
				packageID. reportInstanceVersionGUID: retrieve a single version of a report
				representing the state of a report when it was saved. This may be used in
				conjunctions with a packageID.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attribute name="reportID" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>This ID represents the report to be
							displayed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="packageID" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>This ID represents the Package that contains the report to
							be displayed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="reportInstanceGuid" type="xs:string"/>
				<xs:attribute name="reportInstanceVersonGuid" type="xs:string"/>
				<xs:attribute name="displayState" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActPreviewReportType">
		<xs:annotation>
			<xs:documentation>Show a report preview, based on data in the current form. The
				following parameter may be used: reportID: points to a report definition in SDC
				format.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attribute name="reportID" type="URI_Atype">
					<xs:annotation>
						<xs:documentation>This ID represents the report to be
							displayed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="displayState" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActSendReportType">
		<xs:annotation>
			<xs:documentation>Send a report to an endpoint, via email, fax or web service. The
				default report will be transmittted in SDCSubmitForm format, but may adopt a custom
				report type</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:choice maxOccurs="unbounded">
					<xs:element name="Email" type="EmailAddressType"/>
					<xs:element name="Fax" type="PhoneNumberType"/>
					<xs:element name="WebService" type="CallFuncActionType"/>
				</xs:choice>
				<xs:attribute name="reportID" type="URI_Atype"/>
				<xs:attribute name="reportInstanceGuid" type="xs:string"/>
				<xs:attribute name="reportInstanceVersonGuid" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActSendMessageType">
		<xs:annotation>
			<xs:documentation>Send a message to any endpoint. Messages may include alerts of various
				types. The default datatype for messages is string.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RichTextType">
				<xs:choice>
					<xs:element name="Email" type="EmailAddressType" maxOccurs="unbounded"/>
					<xs:element name="Fax" type="PhoneNumberType" maxOccurs="unbounded"/>
					<xs:element name="WebService" type="CallFuncActionType" maxOccurs="unbounded"/>
				</xs:choice>
				<xs:attribute name="messageType" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActValidateFormType">
		<xs:annotation>
			<xs:documentation>Test the data in the form for proper data types, rule integrity, and
				completeness of required questions.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:sequence minOccurs="0">
					<xs:element minOccurs="0" name="ValidationWebService" type="CallFuncActionType"/>
				</xs:sequence>
				<xs:attribute default="false" name="validateDataTypes" type="xs:boolean"/>
				<xs:attribute default="false" name="validateRules" type="xs:boolean"/>
				<xs:attribute default="false" name="validateCompleteness" type="xs:boolean"/>
				<xs:attribute name="validationType" type="xs:string"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActInjectType">
		<xs:annotation>
			<xs:documentation>Inject a form or part of a form at the specified location. The
				injected section may come from the current form.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="InjectFormType">
				<xs:attribute name="targetNames" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>The names of the parent items that will have the form (or
							form section) injected as child node(s).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			<xs:extension base="ExtensionBaseType">
				<xs:group maxOccurs="unbounded" minOccurs="0" ref="ParameterGroup"/>
				<xs:attribute name="action" type="xs:string" use="required"/>
		<xs:complexContent>
<<<<<<<<< Temporary merge branch 1
			<xs:extension base="ExtensionBaseType">
				<xs:choice maxOccurs="unbounded" minOccurs="0">
					<xs:element maxOccurs="unbounded" minOccurs="0" name="Parameter"
						type="ParameterItemType"/>
					<xs:element minOccurs="0" name="ParameterValue" type="ParameterValueType"
						maxOccurs="unbounded"/>
				</xs:choice>
				<xs:attribute name="action" type="xs:string" use="required"/>
=========
			<xs:extension
				base="ExtensionBaseType">
				<xs:group
					maxOccurs="unbounded"
					minOccurs="0"
					ref="ParameterGroup"/>
					<xs:element name="SelectMatchingListItems" type="RuleSelectMatchingListItemsType"> </xs:element>
					<xs:element name="AddCode" type="ActAddCodeType"/>
					<xs:element name="Inject" type="ActInjectType"/>
					<xs:element name="ShowURL" type="CallFuncActionType"/>
					<xs:element name="Save" type="ActSaveResponsesType"/>
					<xs:element name="SendReport" type="ActSendReportType"/>
					<xs:element name="SendMessage111" type="ActSendMessageType"/>
					<xs:element name="SetAttributeValue" type="ActSetAttributeType"/>
					<xs:element name="SetAttributeValueScript" type="ActSetAttrValueScriptType"/>
					<xs:element name="SetBoolAttributeValueCode" type="ActSetBoolAttributeValueCodeType"/>
					<xs:element name="ShowForm" type="ActShowFormType"/>
					<xs:element name="ShowMessage" type="ActShowMessageType"/>
					<xs:element name="ShowReport" type="ActShowReportType"/>
					<xs:element name="PreviewReport" type="ActPreviewReportType"/>
					<xs:element name="ValidateForm" type="ActValidateFormType"/>
					<xs:element name="RunCode" type="ScriptCodeAnyType"/>
					<xs:element name="CallFunction" type="CallFuncActionType">
					<xs:element
						name="ShowForm"
						type="ActShowFormType"/>
					<xs:element
						name="ShowMessage"
						type="ActShowMessageType"/>
					<xs:element
						name="ShowReport"
						type="ActShowReportType"/>
					<xs:element
						name="PreviewReport"
						type="ActPreviewReportType"/>
					<xs:element
						name="ValidateForm"
						type="ActValidateFormType"/>
					<xs:element
						name="RunCode"
						type="ScriptCodeAnyType"/>
					<xs:element
						name="CallFunction"
						type="CallFuncActionType">
>>>>>>>>> Temporary merge branch 2
						<xs:annotation>
							<xs:documentation>Execute a local rule located elsewhere in the
								FormDesign template. Use the @name value in @val property of
								Function</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ConditionalGroupAction" type="PredActionType"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:attributeGroup name="SelectionDependencyAttributes">
		<xs:attributeGroup ref="BoolAttributes"/>
		<xs:attribute use="required" name="selectedItemSet" type="xs:NMTOKENS">
			<xs:annotation>
				<xs:documentation>This list contains names of ListItems (answer choices) that are
					watched for being selected or unselected. If a ListItem appears in this list,
					then it evaluates to true when it is selected. If a ListItem is prefixed with a
					hyphen (-), then it evaluates to true when unselected. These Boolean values,
					derived from each named ListItem in the list, are ANDed together (by default) to
					produce a return value of true or false. The default Boolean operator (AND) may
					be changed using @boolOp. If @not = true, then the Boolean result is logically
					negated. Renamed from: ListItemSelections</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="RuleSelectMatchingListItemsType">
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:sequence>
					<xs:element name="MatchSource" type="ItemNameAttributeType"/>
					<xs:element name="ListItemMatchTargets" type="RuleListItemMatchTargetsType"> </xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleAutoSelectType">
		<xs:annotation>
			<xs:documentation>This Rule selects/unselects ListItems based on the selected status of
				other ListItems. This declarative rule determines (guards) when target ListItems
				should be selected or unselected. The guard rule may optionally select/unselect
				multiple target ListItems with a single rule. The target ListItem(s) to
				select/unselect are listed in targetNameSelectList. In the simplest case, this rule
				operates as follows: A list of ListItems is provided (selectedItemWatchList). If all
				the items in the list are selected (or unselected - see below) as specified in the
				selectedItemWatchList list, then the guard evaluates to true, and the
				targetNameSelectList items are selected. In some cases, we may wish to watch
				unselected items in the selectedItemWatchList. This is indicated by prefixing the
				name of the watched item with a minus sign/dash ("-"). In some cases, we may wish to
				unselect items in the targetNameSelectList list when the selectedItemWatchList
				evaluated to true. In this case, the target item is prefixed with a dash ("-").
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attributeGroup ref="SelectionDependencyAttributes"/>
				<xs:attributeGroup ref="IfAttributes"/>
				<xs:attribute name="targetNameSelectList" type="xs:NCName">
					<xs:annotation>
						<xs:documentation>This list contains the @names of ListItems that will be
							automatically selected or deselected when the @selectedItemSet evaluates
							to true. If a @name is prefixed with a hyphen (-), then the item will be
							deselected when @selectedItemSet evaluates to true. If @not = true, then
							the Boolean rule evaluation is negated, and thus the rule works in
							reverse. If @onlyIf is true, then the above rule is reversed when
							@selectedItemSet evaluates to false. In other words, named items will be
							deselected, and hyphen-prefixed items will be selected when
							@selectedItemSet is false. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleAutoActivateType">
		<xs:annotation>
			<xs:documentation>This Rule sets the activation status of Items based on the selection
				status of other ListItems. This declarative rule determines (guards) when target
				Items should be activated or deactivated. The rule may optionally
				activate/deactivate multiple target items with a single rule. The target item(s) to
				activate/deactivate are listed in targetNameList. In the simplest case, this rule
				operates as follows: A list of ListItems is provided (selectedItemWatchList). If all
				the items in the list are selected (or unselected - see below) as specified in the
				selectedItemWatchList list, then the guard evaluates to true, and the targetNameList
				items are activated/deactivated. In some cases, we may wish to watch unselected
				items in the selectedItemWatchList. This is indicated by prefixing the name of the
				watched item with a minus sign/dash ("-"). In some cases, we may wish to deactivate
				items in the targetNameSelectList list when the selectedItemWatchList evaluated to
				true. In this case, the target item is prefixed with a dash ("-").
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attributeGroup ref="SelectionDependencyAttributes"/>
				<xs:attributeGroup ref="IfAttributes"/>
				<xs:attribute name="targetNameActivationList" type="xs:NCName">
					<xs:annotation>
						<xs:documentation>This list contains the @names of Identified Items that
							will be automatically activated or deactivated when the @selectedItemSet
							evaluates to true. If a @name is prefixed with a hyphen (-), then the
							item will be deactivated when @selectedItemSet evaluates to true. If
							@not = true, then the Boolean rule evaluation is negated, and thus the
							rule works in reverse. If @onlyIf is true, then the above rule is
							reversed when @selectedItemSet evaluates to false. In other words, named
							items will be deactivated, and hyphen-prefixed items will be activated
							when @selectedItemSet is false. </xs:documentation>
					</xs:annotation>
				<xs:attribute default="false" name="X_removeResponsesWhenDeactivated" type="xs:boolean">
				<xs:attribute default="true" name="setEnabled" type="toggleType">
					<xs:annotation>
						<xs:documentation>Make target items enabled when activated and vice versa.
							Default = true. All descendants are affected in the same
							way.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="true" name="setExpanded" type="toggleType">
					<xs:annotation>
						<xs:documentation>Expand target items when activated and collapse item when
							deactivated. Default = false. All descendants are affected in the same
							way.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
<<<<<<<<< Temporary merge branch 1
				<xs:attribute default="false" name="X_removeResponsesWhenDeactivated"
=========
				<xs:attribute
					default="false"
					name="X_removeResponsesWhenDeactivated"
>>>>>>>>> Temporary merge branch 2
					type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Delete all user selections, responses and comments when
							the item is deactivated. Applies to all descendant items as well. User
							should be warned before deleting anything, with an option to preserve
							the responses in the disabled items. Disabled item responses should not
							be saved with the form data.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RuleListItemMatchTargetsType">
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:attribute name="MatchListItems" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>Takes the @name of one or more target ListItem elements.
							If the source value matches the match supplied attribute criteria, then
							the ListItem(s) should be selcted. The named Question and target
							ListItem must be activated (visible and enabled) in order for it to be
							selected. Read-only ListItems can be selected in the same manner.
							Multiple ListItem names may be specified, separated by
							spaces.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MatchQuestions" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>Takes the @name of a Question element with ListItems. If
							the source value matches the @associatedValue (or other
							@attributeToMatch) of one or more ListItems, then the ListItem(s) should
							be selcted. The named Question and target ListItem must be activated
							(visible and enabled) in order for it to be selected. Read-only
							Questions/ListItems can be selected in the same manner. Multiple Queston
							names may be specified, separated by spaces.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="associatedValue" name="attributeToMatch">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="associatedValue"/>
							<xs:enumeration value="Code"/>
							<xs:enumeration value="TypeValue"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PredSelectionTestType">
		<xs:annotation>
			<xs:documentation>This Rule specifies a set of ListItems that cannot be selected
				(@listItemNames) when a test ListItem (@testItemName) is selected. If any selection
				occurs in @listItemNames when @testItemName is selected, the rule evaluate to true.
				In all other cases, the rule evaluates to false. Multiple selections in
				@listItemNames are acceptable as long as @testItemName is unselected, and in this
				case, the rule evaluates to false. "Legal" (allowed) selections evaluate to false
				"Illegal" selections evaluate to true Renamed from:
				IllegalSelectionTest</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="PredSingleSelectionSetsType">
				<xs:attribute name="testItemName" type="xs:NMTOKEN" use="required">
					<xs:annotation>
						<xs:documentation>The ListItem that is being evaluated for the presence of
							disallowed selections (in @listItemNames). This attributes contains the
							@name of one ListItem.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PredSingleSelectionSetsType">
		<xs:annotation>
			<xs:documentation>This Rule tests combinations of co-selected ListItems (answers). If
				more than X items in the @listItemNames list are selected, then the result returns
				the value of true. Otherwise it is false. X is specified in @maxSelections, and the
				default is 1. The most common use is to detect ListItem combinations that may not be
				selected together. In most cases, all ListItems should be children of one
				multi-select question. Delete this: Legal ("allowed") selections evaluate to false
				Illegal selections evaluate to true These values can be reversed if @not is set to
				true Renamed from: IllegalSelectionSets</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="FuncBoolBaseType">
				<xs:attribute name="listItemNames" type="xs:NMTOKENS" use="required">
					<xs:annotation>
						<xs:documentation>Set of @name references for a set ListItems, delimited by
							spaces.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="1" name="maxSelections" type="xs:short">
					<xs:annotation>
						<xs:documentation>The maximum number of ListItems in @listItemNames that may
							be selected at one time.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
			<xs:extension base="FuncBoolBaseType">
				<xs:attributeGroup ref="BoolAttributes"/>
				<xs:attribute name="itemNames" type="xs:NMTOKENS" use="required">
					<xs:annotation>
						<xs:documentation>If the value is peceded by a colon (:) sign, then it is a reference to the @val attribute of another element.  References can refer to any element with an @val attribute or @propVal on a Property.  The datatype must be cast to the appropriate target datatype.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="hasValueLT" type="xs:string"/>
				<xs:attribute name="hasValueLTE" type="xs:string"/>
				<xs:attribute name="hasValueGT" type="xs:string"/>
				<xs:attribute name="hasValueGTE" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueEQ" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueLT" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueLTE" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueGT" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueGTE" type="xs:string"/>
=========
			<xs:extension
				base="FuncBoolBaseType">
				<xs:attributeGroup
					ref="BoolAttributes"/>
				<xs:attribute
					name="itemNames"
					type="xs:NMTOKENS"
					use="required">
					<xs:annotation>
						<xs:documentation>Required. This attribute holds the @name attributes of the
							item(s) (Section, Question, List Item) to interrogate. These named items
							will be searched for attribute values specified in this Type. If a named
							item does not have a particualr attribute, then the attribute condition
							is ignored for that named item. It does not generate an error or a null
							propagation response.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="isSelected" type="xs:boolean"/>
				<xs:attribute name="isActive" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>If visible and enabled are both true, then isActive is
							true. Otherwise, it is false.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="hasSelectionsGTE" type="xs:nonNegativeInteger">
					<xs:annotation>
						<xs:documentation>Applies only to Questions that have selection lists
							(ListItems or LookupField). Evaluates to true if the number of selected
							items equals or exceeds the entered value.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="hasSelectionsLTE" type="xs:nonNegativeInteger">
					<xs:annotation>
						<xs:documentation>Applies only to Questions that have selection lists
							(ListItems or LookupField). Evaluates to true if the number of selected
							items is less than or equal to the entered value.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="hasSelectionsExact" type="xs:nonNegativeInteger">
					<xs:annotation>
						<xs:documentation>Applies only to Questions that have selection lists
							(ListItems or LookupField). Evaluates to true if the number of selected
							items equals the entered value.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="hasResponse" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Applies only to items that have Response Fields (Questions
							and ListItems). If the ListItem or Question has a Response Field, and
							that field has a value in it, this property returns true. If it does not
							have a value, it returns false. If no Response Field is present, it
							retuns null and is not used for Boolean comparisons. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="isVisible" type="xs:boolean"/>
				<xs:attribute name="hasValueLT" type="xs:string"/>
				<xs:attribute name="hasValueLTE" type="xs:string"/>
				<xs:attribute name="hasValueGT" type="xs:string"/>
				<xs:attribute name="hasValueGTE" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueEQ" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueLT" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueLTE" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueGT" type="xs:string"/>
				<xs:attribute name="hasAssociatedValueGTE" type="xs:string"/>
				<xs:attribute
					name="hasValueGT"
					type="xs:string"/>
				<xs:attribute
					name="hasValueGTE"
					type="xs:string"/>
				<xs:attribute
					name="hasAssociatedValueEQ"
					type="xs:string"/>
				<xs:attribute
					name="hasAssociatedValueLT"
					type="xs:string"/>
				<xs:attribute
					name="hasAssociatedValueLTE"
					type="xs:string"/>
				<xs:attribute
					name="hasAssociatedValueGT"
					type="xs:string"/>
				<xs:attribute
					name="hasAssociatedValueGTE"
					type="xs:string"/>
>>>>>>>>> Temporary merge branch 2
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PredAlternativesType">
		<xs:annotation>
			<xs:documentation>This Rule tests if one (or more) items in a list of items has received
				a a valid user response (answer). In the simplest case, this Rule allows a user to
				answer only one of several alternative questions (named in the @itemNames list), and
				still save a successfully-validated form. In more complex cases, a user can be
				required to produce a valid response to a specific minimum and maximum number of
				Questions, Sections, ListItems or Injected parts. The minCard value on each of the
				alternative items should be set to "0" (i.e., optional) to avoid validation
				conflicts when minCard greater than 0. The list of Item @name values is contained in
				@itemNames. The list must contain at least 2 @name values. The minimum number of
				items to answer is contained in @minAnswered (default value = 1). If there is a
				maximum number of items to answer, the value is contained in @maxAnswered (default
				value = 0 meaning unlimited).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="FuncBoolBaseType">
				<xs:attributeGroup ref="NotAttribute"/>
				<xs:attribute default="1" name="minAnswered" type="xs:int" use="optional"/>
				<xs:attribute default="0" name="maxAnswered" type="xs:int">
					<xs:annotation>
						<xs:documentation>@maxAnswered must be 0 or greater than or equal to
							@minAnswered.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="itemNames" type="xs:NMTOKENS">
					<xs:annotation>
						<xs:documentation>List of names of Sections, Questions, ListItems and/or
							InjectedItems. Each of the named items will evaluate to true or false,
							based on the following validation rules: If the name points to a
							Section, then the Section evaluates to true (valid) if all of its
							descendant items are answered correctly, according to their metadata. If
							the name points to a Question then the Question evaluates to true
							(valid) if it is correctly answered according to its metadata, and also,
							all descendant items are answered correctly, according to their
							metadata. If the name points to a ListItem then the ListItem evaluates
							to true (valid) if it is selected, and also, all descendant items are
							answered correctly according to their metadata. If the name points to an
							InjectedItem then the InjectedItem evaluates to true (valid) if all
							descendant items are answered correctly, according to their metadata.
							The number of true responses are added together. If they satisfy the
							minAnswered and maxAnswered attribute values, then this type returns
							true. Otherwise it returns false. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PredGuardType">
		<xs:complexContent>
			<xs:extension base="FuncBoolBaseType">
				<xs:choice maxOccurs="unbounded">
					<xs:element name="AttributeEval" type="PredEvalAttribValuesType"> </xs:element>
					<xs:element name="ScriptBoolFunc" type="ScriptCodeBoolType"> </xs:element>
					<xs:element name="CallBoolFunc" type="CallFuncBoolType"/>
				<xs:attributeGroup ref="BoolAttributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PredActionType">
		<xs:complexContent>
			<xs:extension base="FuncBoolBaseType">
				<xs:sequence>
					<xs:choice maxOccurs="unbounded" minOccurs="0">
						<xs:element name="AttributeEval" type="AttributeEvalActionType"> </xs:element>
						<xs:element name="ScriptBoolFunc" type="ScriptBoolFuncActionType"> </xs:element>
						<xs:element name="CallBoolFunction" type="CallFuncBoolActionType"/>
						<xs:element name="MultiSelections" type="MultiSelectionsActionType"> </xs:element>
						<xs:element name="SelectionSets" type="SelectionSetsActionType"> </xs:element>
						<xs:element name="SelectionTest" type="SelectionTestActionType">
=========
					<xs:choice
						maxOccurs="unbounded"
						minOccurs="0">
						<xs:element
							name="AttributeEval"
							type="AttributeEvalActionType"> </xs:element>
						<xs:element
							name="ScriptBoolFunc"
							type="ScriptBoolFuncActionType"> </xs:element>
						<xs:element
							name="CallBoolFunction"
							type="CallFuncBoolActionType"/>
						<xs:element
							name="MultiSelections"
							type="MultiSelectionsActionType"> </xs:element>
						<xs:element
							name="SelectionSets"
							type="SelectionSetsActionType"> </xs:element>
						<xs:element
							name="SelectionTest"
							type="SelectionTestActionType">
							<xs:annotation>
								<xs:documentation/>
							</xs:annotation>
						</xs:element>
						<xs:element name="Group" type="PredActionType"/>
						<xs:element name="SelectMatchingListItems" type="RuleSelectMatchingListItemsType"/>
					</xs:choice>
					<xs:group ref="ActionElseType"/>
				</xs:sequence>
				<xs:attributeGroup ref="BoolAttributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="PredActionType2">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="PredGuardType">
					<xs:group ref="ActionElseType"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="RulesType">
		<xs:annotation>
			<xs:documentation>Rules are procedures that affect form behaviour. They are usually
				triggered by changes to the form by a form user. They may also be triggered by other
				rules or changes to form metadata (e.g., change to @visible). SDC decarative form
				rules consist of several types: Assertions are "predicate" expressions that evaulate
				to true or false, based upon the state of answers/responses or metadata within a
				form. An asserion is equivalent to the "If" part of an If-Then block. The
				implementation framework must assign a fucntion to handle any assertion that
				evaluates to False. Assertions are no handled by the form itself. If-Then-Else
				blocks run a "Then" action if the "If block evaluated to true, and an "Else" block
				if the "If" block evaluates to false. An AutoSelection rule automatically selects an
				answer choice (ListItem) when another answer (or set of answers) is selected or
				unselected. IllegalSelectionTest evaluates to true if a disallowed set of answer
				choices is selected at the same time. The implementation should take an action
				(alert user, cancel inout, etc) when a true result occurs. IllegalSelection Set
				restricts combinations of co-selected ListItems (answers). In other words, only zero
				or one item in this list may be selected at a time. </xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:sequence maxOccurs="unbounded">
					<xs:element minOccurs="0" name="Validation" type="ValidationType"> </xs:element>
					<xs:element name="AutoActivation" type="RuleAutoActivateType" maxOccurs="unbounded" minOccurs="0"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="AutoSelection" type="RuleAutoSelectType"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="SelectMatchingListItems"
						type="RuleSelectMatchingListItemsType"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ConditionalActions" type="PredActionType"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ScriptedRule" type="ScriptCodeAnyType">
						<xs:annotation>
							<xs:documentation/>
						</xs:annotation>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ExternalRule" type="CallFuncActionType">
						<xs:annotation>
							<xs:documentation>Rules that are called (by referencing the rule's @name
								attribute) from another place in the form.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CallFuncActionType">
		<xs:annotation>
			<xs:documentation>Function or web service that returns a string
				value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CallFuncType">
				<xs:sequence>
					<xs:annotation>
						<xs:documentation/>
					</xs:annotation>
					<xs:element name="ConditionalActions" type="PredActionType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Actions to take, usually based on the return @val
								value of the function. Condiitons may be specified for each action.
								Conditions may be combined by Boolean operators and nested to any
								level.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CallFuncBoolActionType">
		<xs:annotation>
			<xs:documentation>Function or web service that returns a string
				value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="CallFuncBoolType">
				<xs:choice>
					<xs:annotation>
						<xs:documentation/>
					</xs:annotation>
					<xs:element name="ConditionalActions" type="PredActionType">
						<xs:annotation>
							<xs:documentation>Actions to take, usually based on the return @val
								value of the function. Condiitons may be specified for each action.
								Conditions may be combined by Boolean operators and nested to any
								level.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:group ref="ActionElseType"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ScriptBoolFuncActionType">
		<xs:complexContent>
			<xs:extension base="ScriptCodeBoolType">
				<xs:choice>
					<xs:annotation>
						<xs:documentation/>
					</xs:annotation>
					<xs:element name="ConditionalActions" type="PredActionType">
						<xs:annotation>
							<xs:documentation>Actions to take, usually based on the return @val
								value of the function. Condiitons may be specified for each action.
								Conditions may be combined by Boolean operators and nested to any
								level.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:group ref="ActionElseType"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AttributeEvalActionType">
		<xs:complexContent>
			<xs:extension base="PredEvalAttribValuesType">
				<xs:group ref="ActionElseType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValidationType">
		<xs:complexContent>
			<xs:extension base="ExtensionBaseType">
				<xs:choice maxOccurs="unbounded">
					<xs:element maxOccurs="unbounded" minOccurs="0" name="SelectionTest">
						<xs:annotation>
							<xs:documentation/>
						</xs:annotation>
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="PredSelectionTestType">
									<xs:attributeGroup ref="NotAttribute"/>
										<xs:element maxOccurs="unbounded" minOccurs="0"
											name="IllegalSelectionTest" type="RuleSelectionTestType">
											<xs:annotation>
												<xs:documentation/>
					<xs:element name="SelectionSets" maxOccurs="unbounded" minOccurs="0">
						</xs:complexType>
					</xs:element>
<<<<<<<<< Temporary merge branch 1
					<xs:element name="AutoActivation" type="RuleAutoActivationType"
						maxOccurs="unbounded" minOccurs="0"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="AutoSelection"
						type="RuleAutoSelectType"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ConditionalGroupActions"
					<xs:element name="ItemAlternatives" maxOccurs="unbounded" minOccurs="0" type="PredAlternativesType">
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" name="ExternalRule"
						type="CallFuncType">
=========
					<xs:element
						name="SelectionSets"
						maxOccurs="unbounded"
						minOccurs="0">
	<xs:group name="ActionElseType">
					<xs:annotation>
						<xs:documentation>Takes the @name of a Question element with ListItems.  If the source value matches the @associatedValue (or other @attributeToMatch) of one or more ListItems, then the ListItem(s) should be selcted. The named Question and target ListItem must be activated (visible and enabled) in order for it to be selected.

Read-only Questions/ListItems can be selected in the same manner.
Multiple Queston names may be specified, separated by spaces.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute default="associatedValue" name="attributeToMatch">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="associatedValue"/>
							<xs:enumeration value="Code"/>
							<xs:enumeration value="TypeValue"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
=========
	<xs:group
		name="ActionElseType">
		<xs:sequence>
			<xs:element name="Actions" minOccurs="0" type="ActionsType"/>
			<xs:element minOccurs="0" name="Else" type="PredActionType" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:group>
</xs:schema>
